#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR';
  # Error.pm
  #
  # Copyright (c) 1997-8 Graham Barr <gbarr@ti.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Based on my original Error.pm, and Exceptions.pm by Peter Seibel
  # <peter@weblogic.com> and adapted by Jesse Glick <jglick@sig.bsh.com>.
  #
  # but modified ***significantly***
  
  package Error;
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  use 5.004;
  
  $VERSION = "0.17022";
  
  use overload (
  	'""'	   =>	'stringify',
  	'0+'	   =>	'value',
  	'bool'     =>	sub { return 1; },
  	'fallback' =>	1
  );
  
  $Error::Depth = 0;	# Depth to pass to caller()
  $Error::Debug = 0;	# Generate verbose stack traces
  @Error::STACK = ();	# Clause stack for try
  $Error::THROWN = undef;	# last error thrown, a workaround until die $ref works
  
  my $LAST;		# Last error created
  my %ERROR;		# Last error associated with package
  
  sub _throw_Error_Simple
  {
      my $args = shift;
      return Error::Simple->new($args->{'text'});
  }
  
  $Error::ObjectifyCallback = \&_throw_Error_Simple;
  
  
  # Exported subs are defined in Error::subs
  
  use Scalar::Util ();
  
  sub import {
      shift;
      my @tags = @_;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
  
      @tags = grep {
         if( $_ eq ':warndie' ) {
            Error::WarnDie->import();
            0;
         }
         else {
            1;
         }
      } @tags;
  
      Error::subs->import(@tags);
  }
  
  # I really want to use last for the name of this method, but it is a keyword
  # which prevent the syntax  last Error
  
  sub prior {
      shift; # ignore
  
      return $LAST unless @_;
  
      my $pkg = shift;
      return exists $ERROR{$pkg} ? $ERROR{$pkg} : undef
  	unless ref($pkg);
  
      my $obj = $pkg;
      my $err = undef;
      if($obj->isa('HASH')) {
  	$err = $obj->{'__Error__'}
  	    if exists $obj->{'__Error__'};
      }
      elsif($obj->isa('GLOB')) {
  	$err = ${*$obj}{'__Error__'}
  	    if exists ${*$obj}{'__Error__'};
      }
  
      $err;
  }
  
  sub flush {
      shift; #ignore
  
      unless (@_) {
         $LAST = undef;
         return;
      }
  
      my $pkg = shift;
      return unless ref($pkg);
  
      undef $ERROR{$pkg} if defined $ERROR{$pkg};
  }
  
  # Return as much information as possible about where the error
  # happened. The -stacktrace element only exists if $Error::DEBUG
  # was set when the error was created
  
  sub stacktrace {
      my $self = shift;
  
      return $self->{'-stacktrace'}
  	if exists $self->{'-stacktrace'};
  
      my $text = exists $self->{'-text'} ? $self->{'-text'} : "Died";
  
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
  
      $text;
  }
  
  
  sub associate {
      my $err = shift;
      my $obj = shift;
  
      return unless ref($obj);
  
      if($obj->isa('HASH')) {
  	$obj->{'__Error__'} = $err;
      }
      elsif($obj->isa('GLOB')) {
  	${*$obj}{'__Error__'} = $err;
      }
      $obj = ref($obj);
      $ERROR{ ref($obj) } = $err;
  
      return;
  }
  
  
  sub new {
      my $self = shift;
      my($pkg,$file,$line) = caller($Error::Depth);
  
      my $err = bless {
  	'-package' => $pkg,
  	'-file'    => $file,
  	'-line'    => $line,
  	@_
      }, $self;
  
      $err->associate($err->{'-object'})
  	if(exists $err->{'-object'});
  
      # To always create a stacktrace would be very inefficient, so
      # we only do it if $Error::Debug is set
  
      if($Error::Debug) {
  	require Carp;
  	local $Carp::CarpLevel = $Error::Depth;
  	my $text = defined($err->{'-text'}) ? $err->{'-text'} : "Error";
  	my $trace = Carp::longmess($text);
  	# Remove try calls from the trace
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
  	$err->{'-stacktrace'} = $trace
      }
  
      $@ = $LAST = $ERROR{$pkg} = $err;
  }
  
  # Throw an error. this contains some very gory code.
  
  sub throw {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      # if we are not rethrow-ing then create the object to throw
      $self = $self->new(@_) unless ref($self);
  
      die $Error::THROWN = $self;
  }
  
  # syntactic sugar for
  #
  #    die with Error( ... );
  
  sub with {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # syntactic sugar for
  #
  #    record Error( ... ) and return;
  
  sub record {
      my $self = shift;
      local $Error::Depth = $Error::Depth + 1;
  
      $self->new(@_);
  }
  
  # catch clause for
  #
  # try { ... } catch CLASS with { ... }
  
  sub catch {
      my $pkg = shift;
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      unshift @$catch,  $pkg, $code;
  
      $clauses;
  }
  
  # Object query methods
  
  sub object {
      my $self = shift;
      exists $self->{'-object'} ? $self->{'-object'} : undef;
  }
  
  sub file {
      my $self = shift;
      exists $self->{'-file'} ? $self->{'-file'} : undef;
  }
  
  sub line {
      my $self = shift;
      exists $self->{'-line'} ? $self->{'-line'} : undef;
  }
  
  sub text {
      my $self = shift;
      exists $self->{'-text'} ? $self->{'-text'} : undef;
  }
  
  # overload methods
  
  sub stringify {
      my $self = shift;
      defined $self->{'-text'} ? $self->{'-text'} : "Died";
  }
  
  sub value {
      my $self = shift;
      exists $self->{'-value'} ? $self->{'-value'} : undef;
  }
  
  package Error::Simple;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  @Error::Simple::ISA = qw(Error);
  
  sub new {
      my $self  = shift;
      my $text  = "" . shift;
      my $value = shift;
      my(@args) = ();
  
      local $Error::Depth = $Error::Depth + 1;
  
      @args = ( -file => $1, -line => $2)
  	if($text =~ s/\s+at\s+(\S+)\s+line\s+(\d+)(?:,\s*<[^>]*>\s+line\s+\d+)?\.?\n?$//s);
      push(@args, '-value', 0 + $value)
  	if defined($value);
  
      $self->SUPER::new(-text => $text, @args);
  }
  
  sub stringify {
      my $self = shift;
      my $text = $self->SUPER::stringify;
      $text .= sprintf(" at %s line %d.\n", $self->file, $self->line)
  	unless($text =~ /\n$/s);
      $text;
  }
  
  ##########################################################################
  ##########################################################################
  
  # Inspired by code from Jesse Glick <jglick@sig.bsh.com> and
  # Peter Seibel <peter@weblogic.com>
  
  package Error::subs;
  
  use Exporter ();
  use vars qw(@EXPORT_OK @ISA %EXPORT_TAGS);
  
  @EXPORT_OK   = qw(try with finally except otherwise);
  %EXPORT_TAGS = (try => \@EXPORT_OK);
  
  @ISA = qw(Exporter);
  
  sub run_clauses ($$$\@) {
      my($clauses,$err,$wantarray,$result) = @_;
      my $code = undef;
  
      $err = $Error::ObjectifyCallback->({'text' =>$err}) unless ref($err);
  
      CATCH: {
  
  	# catch
  	my $catch;
  	if(defined($catch = $clauses->{'catch'})) {
  	    my $i = 0;
  
  	    CATCHLOOP:
  	    for( ; $i < @$catch ; $i += 2) {
  		my $pkg = $catch->[$i];
  		unless(defined $pkg) {
  		    #except
  		    splice(@$catch,$i,2,$catch->[$i+1]->($err));
  		    $i -= 2;
  		    next CATCHLOOP;
  		}
  		elsif(Scalar::Util::blessed($err) && $err->isa($pkg)) {
  		    $code = $catch->[$i+1];
  		    while(1) {
  			my $more = 0;
  			local($Error::THROWN, $@);
  			my $ok = eval {
  			    $@ = $err;
  			    if($wantarray) {
  				@{$result} = $code->($err,\$more);
  			    }
  			    elsif(defined($wantarray)) {
  			        @{$result} = ();
  				$result->[0] = $code->($err,\$more);
  			    }
  			    else {
  				$code->($err,\$more);
  			    }
  			    1;
  			};
  			if( $ok ) {
  			    next CATCHLOOP if $more;
  			    undef $err;
  			}
  			else {
  			    $err = $@ || $Error::THROWN;
  				$err = $Error::ObjectifyCallback->({'text' =>$err})
  					unless ref($err);
  			}
  			last CATCH;
  		    };
  		}
  	    }
  	}
  
  	# otherwise
  	my $owise;
  	if(defined($owise = $clauses->{'otherwise'})) {
  	    my $code = $clauses->{'otherwise'};
  	    my $more = 0;
          local($Error::THROWN, $@);
  	    my $ok = eval {
  		$@ = $err;
  		if($wantarray) {
  		    @{$result} = $code->($err,\$more);
  		}
  		elsif(defined($wantarray)) {
  		    @{$result} = ();
  		    $result->[0] = $code->($err,\$more);
  		}
  		else {
  		    $code->($err,\$more);
  		}
  		1;
  	    };
  	    if( $ok ) {
  		undef $err;
  	    }
  	    else {
  		$err = $@ || $Error::THROWN;
  
  		$err = $Error::ObjectifyCallback->({'text' =>$err})
  			unless ref($err);
  	    }
  	}
      }
      $err;
  }
  
  sub try (&;$) {
      my $try = shift;
      my $clauses = @_ ? shift : {};
      my $ok = 0;
      my $err = undef;
      my @result = ();
  
      unshift @Error::STACK, $clauses;
  
      my $wantarray = wantarray();
  
      do {
  	local $Error::THROWN = undef;
  	local $@ = undef;
  
  	$ok = eval {
  	    if($wantarray) {
  		@result = $try->();
  	    }
  	    elsif(defined $wantarray) {
  		$result[0] = $try->();
  	    }
  	    else {
  		$try->();
  	    }
  	    1;
  	};
  
  	$err = $@ || $Error::THROWN
  	    unless $ok;
      };
  
      shift @Error::STACK;
  
      $err = run_clauses($clauses,$err,wantarray,@result)
      unless($ok);
  
      $clauses->{'finally'}->()
  	if(defined($clauses->{'finally'}));
  
      if (defined($err))
      {
          if (Scalar::Util::blessed($err) && $err->can('throw'))
          {
              throw $err;
          }
          else
          {
              die $err;
          }
      }
  
      wantarray ? @result : $result[0];
  }
  
  # Each clause adds a sub to the list of clauses. The finally clause is
  # always the last, and the otherwise clause is always added just before
  # the finally clause.
  #
  # All clauses, except the finally clause, add a sub which takes one argument
  # this argument will be the error being thrown. The sub will return a code ref
  # if that clause can handle that error, otherwise undef is returned.
  #
  # The otherwise clause adds a sub which unconditionally returns the users
  # code reference, this is why it is forced to be last.
  #
  # The catch clause is defined in Error.pm, as the syntax causes it to
  # be called as a method
  
  sub with (&;$) {
      @_
  }
  
  sub finally (&) {
      my $code = shift;
      my $clauses = { 'finally' => $code };
      $clauses;
  }
  
  # The except clause is a block which returns a hashref or a list of
  # key-value pairs, where the keys are the classes and the values are subs.
  
  sub except (&;$) {
      my $code = shift;
      my $clauses = shift || {};
      my $catch = $clauses->{'catch'} ||= [];
  
      my $sub = sub {
  	my $ref;
  	my(@array) = $code->($_[0]);
  	if(@array == 1 && ref($array[0])) {
  	    $ref = $array[0];
  	    $ref = [ %$ref ]
  		if(UNIVERSAL::isa($ref,'HASH'));
  	}
  	else {
  	    $ref = \@array;
  	}
  	@$ref
      };
  
      unshift @{$catch}, undef, $sub;
  
      $clauses;
  }
  
  sub otherwise (&;$) {
      my $code = shift;
      my $clauses = shift || {};
  
      if(exists $clauses->{'otherwise'}) {
  	require Carp;
  	Carp::croak("Multiple otherwise clauses");
      }
  
      $clauses->{'otherwise'} = $code;
  
      $clauses;
  }
  
  1;
  
  package Error::WarnDie;
  
  sub gen_callstack($)
  {
      my ( $start ) = @_;
  
      require Carp;
      local $Carp::CarpLevel = $start;
      my $trace = Carp::longmess("");
      # Remove try calls from the trace
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      $trace =~ s/(\n\s+\S+__ANON__[^\n]+)?\n\s+eval[^\n]+\n\s+Error::subs::run_clauses[^\n]+\n\s+Error::subs::try[^\n]+(?=\n)//sog;
      my @callstack = split( m/\n/, $trace );
      return @callstack;
  }
  
  my $old_DIE;
  my $old_WARN;
  
  sub DEATH
  {
      my ( $e ) = @_;
  
      local $SIG{__DIE__} = $old_DIE if( defined $old_DIE );
  
      die @_ if $^S;
  
      my ( $etype, $message, $location, @callstack );
      if ( ref($e) && $e->isa( "Error" ) ) {
          $etype = "exception of type " . ref( $e );
          $message = $e->text;
          $location = $e->file . ":" . $e->line;
          @callstack = split( m/\n/, $e->stacktrace );
      }
      else {
          # Don't apply subsequent layer of message formatting
          die $e if( $e =~ m/^\nUnhandled perl error caught at toplevel:\n\n/ );
          $etype = "perl error";
          my $stackdepth = 0;
          while( caller( $stackdepth ) =~ m/^Error(?:$|::)/ ) {
              $stackdepth++
          }
  
          @callstack = gen_callstack( $stackdepth + 1 );
  
          $message = "$e";
          chomp $message;
  
          if ( $message =~ s/ at (.*?) line (\d+)\.$// ) {
              $location = $1 . ":" . $2;
          }
          else {
              my @caller = caller( $stackdepth );
              $location = $caller[1] . ":" . $caller[2];
          }
      }
  
      shift @callstack;
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      die "\nUnhandled $etype caught at toplevel:\n\n  $message\n\nThrown from: $location\n\nFull stack trace:\n\n$callstack\n";
  }
  
  sub TAXES
  {
      my ( $message ) = @_;
  
      local $SIG{__WARN__} = $old_WARN if( defined $old_WARN );
  
      $message =~ s/ at .*? line \d+\.$//;
      chomp $message;
  
      my @callstack = gen_callstack( 1 );
      my $location = shift @callstack;
  
      # $location already starts in a leading space
      $message .= $location;
  
      # Do it this way in case there are no elements; we don't print a spurious \n
      my $callstack = join( "", map { "$_\n"} @callstack );
  
      warn "$message:\n$callstack";
  }
  
  sub import
  {
      $old_DIE  = $SIG{__DIE__};
      $old_WARN = $SIG{__WARN__};
  
      $SIG{__DIE__}  = \&DEATH;
      $SIG{__WARN__} = \&TAXES;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Error - Error/exception handling in an OO-ish way
  
  =head1 WARNING
  
  Using the "Error" module is B<no longer recommended> due to the black-magical
  nature of its syntactic sugar, which often tends to break. Its maintainers
  have stopped actively writing code that uses it, and discourage people
  from doing so. See the "SEE ALSO" section below for better recommendations.
  
  =head1 SYNOPSIS
  
      use Error qw(:try);
  
      throw Error::Simple( "A simple error");
  
      sub xyz {
          ...
  	record Error::Simple("A simple error")
  	    and return;
      }
  
      unlink($file) or throw Error::Simple("$file: $!",$!);
  
      try {
  	do_some_stuff();
  	die "error!" if $condition;
  	throw Error::Simple "Oops!" if $other_condition;
      }
      catch Error::IO with {
  	my $E = shift;
  	print STDERR "File ", $E->{'-file'}, " had a problem\n";
      }
      except {
  	my $E = shift;
  	my $general_handler=sub {send_message $E->{-description}};
  	return {
  	    UserException1 => $general_handler,
  	    UserException2 => $general_handler
  	};
      }
      otherwise {
  	print STDERR "Well I don't know what to say\n";
      }
      finally {
  	close_the_garage_door_already(); # Should be reliable
      }; # Don't forget the trailing ; or you might be surprised
  
  =head1 DESCRIPTION
  
  The C<Error> package provides two interfaces. Firstly C<Error> provides
  a procedural interface to exception handling. Secondly C<Error> is a
  base class for errors/exceptions that can either be thrown, for
  subsequent catch, or can simply be recorded.
  
  Errors in the class C<Error> should not be thrown directly, but the
  user should throw errors from a sub-class of C<Error>.
  
  =head1 PROCEDURAL INTERFACE
  
  C<Error> exports subroutines to perform exception handling. These will
  be exported if the C<:try> tag is used in the C<use> line.
  
  =over 4
  
  =item try BLOCK CLAUSES
  
  C<try> is the main subroutine called by the user. All other subroutines
  exported are clauses to the try subroutine.
  
  The BLOCK will be evaluated and, if no error is throw, try will return
  the result of the block.
  
  C<CLAUSES> are the subroutines below, which describe what to do in the
  event of an error being thrown within BLOCK.
  
  =item catch CLASS with BLOCK
  
  This clauses will cause all errors that satisfy C<$err-E<gt>isa(CLASS)>
  to be caught and handled by evaluating C<BLOCK>.
  
  C<BLOCK> will be passed two arguments. The first will be the error
  being thrown. The second is a reference to a scalar variable. If this
  variable is set by the catch block then, on return from the catch
  block, try will continue processing as if the catch block was never
  found. The error will also be available in C<$@>.
  
  To propagate the error the catch block may call C<$err-E<gt>throw>
  
  If the scalar reference by the second argument is not set, and the
  error is not thrown. Then the current try block will return with the
  result from the catch block.
  
  =item except BLOCK
  
  When C<try> is looking for a handler, if an except clause is found
  C<BLOCK> is evaluated. The return value from this block should be a
  HASHREF or a list of key-value pairs, where the keys are class names
  and the values are CODE references for the handler of errors of that
  type.
  
  =item otherwise BLOCK
  
  Catch any error by executing the code in C<BLOCK>
  
  When evaluated C<BLOCK> will be passed one argument, which will be the
  error being processed. The error will also be available in C<$@>.
  
  Only one otherwise block may be specified per try block
  
  =item finally BLOCK
  
  Execute the code in C<BLOCK> either after the code in the try block has
  successfully completed, or if the try block throws an error then
  C<BLOCK> will be executed after the handler has completed.
  
  If the handler throws an error then the error will be caught, the
  finally block will be executed and the error will be re-thrown.
  
  Only one finally block may be specified per try block
  
  =back
  
  =head1 COMPATIBILITY
  
  L<Moose> exports a keyword called C<with> which clashes with Error's. This
  example returns a prototype mismatch error:
  
      package MyTest;
  
      use warnings;
      use Moose;
      use Error qw(:try);
  
  (Thanks to C<maik.hentsche@amd.com> for the report.).
  
  =head1 CLASS INTERFACE
  
  =head2 CONSTRUCTORS
  
  The C<Error> object is implemented as a HASH. This HASH is initialized
  with the arguments that are passed to it's constructor. The elements
  that are used by, or are retrievable by the C<Error> class are listed
  below, other classes may add to these.
  
  	-file
  	-line
  	-text
  	-value
  	-object
  
  If C<-file> or C<-line> are not specified in the constructor arguments
  then these will be initialized with the file name and line number where
  the constructor was called from.
  
  If the error is associated with an object then the object should be
  passed as the C<-object> argument. This will allow the C<Error> package
  to associate the error with the object.
  
  The C<Error> package remembers the last error created, and also the
  last error associated with a package. This could either be the last
  error created by a sub in that package, or the last error which passed
  an object blessed into that package as the C<-object> argument.
  
  =over 4
  
  =item Error->new()
  
  See the Error::Simple documentation.
  
  =item throw ( [ ARGS ] )
  
  Create a new C<Error> object and throw an error, which will be caught
  by a surrounding C<try> block, if there is one. Otherwise it will cause
  the program to exit.
  
  C<throw> may also be called on an existing error to re-throw it.
  
  =item with ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      die with Some::Error ( ... );
  
  =item record ( [ ARGS ] )
  
  Create a new C<Error> object and returns it. This is defined for
  syntactic sugar, eg
  
      record Some::Error ( ... )
  	and return;
  
  =back
  
  =head2 STATIC METHODS
  
  =over 4
  
  =item prior ( [ PACKAGE ] )
  
  Return the last error created, or the last error associated with
  C<PACKAGE>
  
  =item flush ( [ PACKAGE ] )
  
  Flush the last error created, or the last error associated with
  C<PACKAGE>.It is necessary to clear the error stack before exiting the
  package or uncaught errors generated using C<record> will be reported.
  
       $Error->flush;
  
  =cut
  
  =back
  
  =head2 OBJECT METHODS
  
  =over 4
  
  =item stacktrace
  
  If the variable C<$Error::Debug> was non-zero when the error was
  created, then C<stacktrace> returns a string created by calling
  C<Carp::longmess>. If the variable was zero the C<stacktrace> returns
  the text of the error appended with the filename and line number of
  where the error was created, providing the text does not end with a
  newline.
  
  =item object
  
  The object this error was associated with
  
  =item file
  
  The file where the constructor of this error was called from
  
  =item line
  
  The line where the constructor of this error was called from
  
  =item text
  
  The text of the error
  
  =item $err->associate($obj)
  
  Associates an error with an object to allow error propagation. I.e:
  
      $ber->encode(...) or
          return Error->prior($ber)->associate($ldap);
  
  =back
  
  =head2 OVERLOAD METHODS
  
  =over 4
  
  =item stringify
  
  A method that converts the object into a string. This method may simply
  return the same as the C<text> method, or it may append more
  information. For example the file name and line number.
  
  By default this method returns the C<-text> argument that was passed to
  the constructor, or the string C<"Died"> if none was given.
  
  =item value
  
  A method that will return a value that can be associated with the
  error. For example if an error was created due to the failure of a
  system call, then this may return the numeric value of C<$!> at the
  time.
  
  By default this method returns the C<-value> argument that was passed
  to the constructor.
  
  =back
  
  =head1 PRE-DEFINED ERROR CLASSES
  
  =head2 Error::Simple
  
  This class can be used to hold simple error strings and values. It's
  constructor takes two arguments. The first is a text value, the second
  is a numeric value. These values are what will be returned by the
  overload methods.
  
  If the text value ends with C<at file line 1> as $@ strings do, then
  this information will be used to set the C<-file> and C<-line> arguments
  of the error object.
  
  This class is used internally if an eval'd block die's with an error
  that is a plain string. (Unless C<$Error::ObjectifyCallback> is modified)
  
  
  =head1 $Error::ObjectifyCallback
  
  This variable holds a reference to a subroutine that converts errors that
  are plain strings to objects. It is used by Error.pm to convert textual
  errors to objects, and can be overridden by the user.
  
  It accepts a single argument which is a hash reference to named parameters.
  Currently the only named parameter passed is C<'text'> which is the text
  of the error, but others may be available in the future.
  
  For example the following code will cause Error.pm to throw objects of the
  class MyError::Bar by default:
  
      sub throw_MyError_Bar
      {
          my $args = shift;
          my $err = MyError::Bar->new();
          $err->{'MyBarText'} = $args->{'text'};
          return $err;
      }
  
      {
          local $Error::ObjectifyCallback = \&throw_MyError_Bar;
  
          # Error handling here.
      }
  
  =cut
  
  =head1 MESSAGE HANDLERS
  
  C<Error> also provides handlers to extend the output of the C<warn()> perl
  function, and to handle the printing of a thrown C<Error> that is not caught
  or otherwise handled. These are not installed by default, but are requested
  using the C<:warndie> tag in the C<use> line.
  
   use Error qw( :warndie );
  
  These new error handlers are installed in C<$SIG{__WARN__}> and
  C<$SIG{__DIE__}>. If these handlers are already defined when the tag is
  imported, the old values are stored, and used during the new code. Thus, to
  arrange for custom handling of warnings and errors, you will need to perform
  something like the following:
  
   BEGIN {
     $SIG{__WARN__} = sub {
       print STDERR "My special warning handler: $_[0]"
     };
   }
  
   use Error qw( :warndie );
  
  Note that setting C<$SIG{__WARN__}> after the C<:warndie> tag has been
  imported will overwrite the handler that C<Error> provides. If this cannot be
  avoided, then the tag can be explicitly C<import>ed later
  
   use Error;
  
   $SIG{__WARN__} = ...;
  
   import Error qw( :warndie );
  
  =head2 EXAMPLE
  
  The C<__DIE__> handler turns messages such as
  
   Can't call method "foo" on an undefined value at examples/warndie.pl line 16.
  
  into
  
   Unhandled perl error caught at toplevel:
  
     Can't call method "foo" on an undefined value
  
   Thrown from: examples/warndie.pl:16
  
   Full stack trace:
  
           main::inner('undef') called at examples/warndie.pl line 20
           main::outer('undef') called at examples/warndie.pl line 23
  
  =cut
  
  =head1 SEE ALSO
  
  See L<Exception::Class> for a different module providing Object-Oriented
  exception handling, along with a convenient syntax for declaring hierarchies
  for them. It doesn't provide Error's syntactic sugar of C<try { ... }>,
  C<catch { ... }>, etc. which may be a good thing or a bad thing based
  on what you want. (Because Error's syntactic sugar tends to break.)
  
  L<Error::Exception> aims to combine L<Error> and L<Exception::Class>
  "with correct stringification".
  
  L<TryCatch> and L<Try::Tiny> are similar in concept to Error.pm only providing
  a syntax that hopefully breaks less.
  
  =head1 KNOWN BUGS
  
  None, but that does not mean there are not any.
  
  =head1 AUTHORS
  
  Graham Barr <gbarr@pobox.com>
  
  The code that inspired me to write this was originally written by
  Peter Seibel <peter@weblogic.com> and adapted by Jesse Glick
  <jglick@sig.bsh.com>.
  
  C<:warndie> handlers added by Paul Evans <leonerd@leonerd.org.uk>
  
  =head1 MAINTAINER
  
  Shlomi Fish, L<http://www.shlomifish.org/> .
  
  =head1 PAST MAINTAINERS
  
  Arun Kumar U <u_arunkumar@yahoo.com>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-8  Graham Barr. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
ERROR

$fatpacked{"Error/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'ERROR_SIMPLE';
  # Error/Simple.pm
  #
  # Copyright (c) 2006 Shlomi Fish <shlomif@shlomifish.org>.
  # This file is free software; you can redistribute it and/or
  # modify it under the terms of the MIT/X11 license (whereas the licence
  # of the Error distribution as a whole is the GPLv1+ and the Artistic
  # licence).
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  
  $VERSION = "0.17022";
  
  use Error;
  
  1;
  __END__
  
  =head1 NAME
  
  Error::Simple - the simple error sub-class of Error
  
  =head1 SYNOPSIS
  
      use base 'Error::Simple';
  
  =head1 DESCRIPTION
  
  The only purpose of this module is to allow one to say:
  
      use base 'Error::Simple';
  
  and the only thing it does is "use" Error.pm. Refer to the documentation
  of L<Error> for more information about Error::Simple.
  
  =head1 METHODS
  
  =head2 Error::Simple->new($text [, $value])
  
  Constructs an Error::Simple with the text C<$text> and the optional value
  C<$value>.
  
  =head2 $err->stringify()
  
  Error::Simple overloads this method.
  
  =head1 KNOWN BUGS
  
  None.
  
  =head1 AUTHORS
  
  Shlomi Fish ( L<http://www.shlomifish.org/> )
  
  =head1 SEE ALSO
  
  L<Error>
  
ERROR_SIMPLE

$fatpacked{"File/Slurper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_SLURPER';
  package File::Slurper;
  $File::Slurper::VERSION = '0.008';
  use strict;
  use warnings;
  
  use Carp 'croak';
  use Exporter 5.57 'import';
  our @EXPORT_OK = qw/read_binary read_text read_lines write_binary write_text read_dir/;
  
  sub read_binary {
  	my $filename = shift;
  
  	# This logic is a bit ugly, but gives a significant speed boost
  	# because slurpy readline is not optimized for non-buffered usage
  	open my $fh, '<:unix', $filename or croak "Couldn't open $filename: $!";
  	if (my $size = -s $fh) {
  		my $buf;
  		my ($pos, $read) = 0;
  		do {
  			defined($read = read $fh, ${$buf}, $size - $pos, $pos) or croak "Couldn't read $filename: $!";
  			$pos += $read;
  		} while ($read && $pos < $size);
  		return ${$buf};
  	}
  	else {
  		return do { local $/; <$fh> };
  	}
  }
  
  use constant {
  	CRLF_DEFAULT => $^O eq 'MSWin32',
  	HAS_UTF8_STRICT => scalar do { local $@; eval { require PerlIO::utf8_strict } },
  };
  
  sub _text_layers {
  	my ($encoding, $crlf) = @_;
  	$crlf = CRLF_DEFAULT if $crlf && $crlf eq 'auto';
  
  	if ($encoding =~ /^(latin|iso-8859-)1$/i) {
  		return $crlf ? ':unix:crlf' : ':raw';
  	}
  	elsif (HAS_UTF8_STRICT && $encoding =~ /^utf-?8\b/i) {
  		return $crlf ? ':unix:utf8_strict:crlf' : ':unix:utf8_strict';
  	}
  	else {
  		# non-ascii compatible encodings such as UTF-16 need encoding before crlf
  		return $crlf ? ":raw:encoding($encoding):crlf" : ":raw:encoding($encoding)";
  	}
  }
  
  sub read_text {
  	my ($filename, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  	return read_binary($filename) if $layer eq ':raw';
  
  	local $PerlIO::encoding::fallback = 1;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return do { local $/; <$fh> };
  }
  
  sub write_text {
  	my ($filename, undef, $encoding, $crlf) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = 1;
  	open my $fh, ">$layer", $filename or croak "Couldn't open $filename: $!";
  	print $fh $_[1] or croak "Couldn't write to $filename: $!";
  	close $fh or croak "Couldn't write to $filename: $!";
  	return;
  }
  
  sub write_binary {
  	return write_text(@_[0,1], 'latin-1');
  }
  
  sub read_lines {
  	my ($filename, $encoding, $crlf, $skip_chomp) = @_;
  	$encoding ||= 'utf-8';
  	my $layer = _text_layers($encoding, $crlf);
  
  	local $PerlIO::encoding::fallback = 1;
  	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
  	return <$fh> if $skip_chomp;
  	my @buf = <$fh>;
  	close $fh;
  	chomp @buf;
  	return @buf;
  }
  
  sub read_dir {
  	my ($dirname) = @_;
  	opendir my ($dir), $dirname or croak "Could not open $dirname: $!";
  	return grep { not m/ \A \.\.? \z /x } readdir $dir;
  }
  
  1;
  
  # ABSTRACT: A simple, sane and efficient module to slurp a file
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  File::Slurper - A simple, sane and efficient module to slurp a file
  
  =head1 VERSION
  
  version 0.008
  
  =head1 SYNOPSIS
  
   use File::Slurper 'read_text';
   my $content = read_text($filename);
  
  =head1 DESCRIPTION
  
  This module provides functions for fast and correct slurping and spewing. All functions are optionally exported.
  
  =head1 FUNCTIONS
  
  =head2 read_text($filename, $encoding, $crlf)
  
  Reads file C<$filename> into a scalar and decodes it from C<$encoding> (which defaults to UTF-8). If C<$crlf> is true, crlf translation is performed. The default for this argument is off. The special value C<'auto'> will set it to a platform specific default value.
  
  =head2 read_binary($filename)
  
  Reads file C<$filename> into a scalar without any decoding or transformation.
  
  =head2 read_lines($filename, $encoding, $crlf, $skip_chomp)
  
  Reads file C<$filename> into a list/array line-by-line, after decoding from C<$encoding>, optional crlf translation and chomping.
  
  =head2 write_text($filename, $content, $encoding, $crlf)
  
  Writes C<$content> to file C<$filename>, encoding it to C<$encoding> (which defaults to UTF-8). It can also take a C<crlf> argument that works exactly as in read_text.
  
  =head2 write_binary($filename, $content)
  
  Writes C<$content> to file C<$filename> as binary data.
  
  =head2 read_dir($dirname)
  
  Open C<dirname> and return all entries except C<.> and C<..>.
  
  =head1 RATIONALE
  
  This module tries to make it as easy as possible to read and write files correctly and fast. The most correct way of doing this is not always obvious (e.g. L<#83126|https://rt.cpan.org/Public/Bug/Display.html?id=83126>), and just as often the most obvious correct way is not the fastest correct way. This module hides away all such complications behind an easy intuitive interface.
  
  =head1 DEPENDENCIES
  
  This module has an optional dependency on L<PerlIO::utf8_strict|PerlIO::utf8_strict>. Installing this will make UTF-8 encoded IO significantly faster, but should not otherwise affect the operation of this module. This may change into a dependency on the related Unicode::UTF8 in the future.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item * L<Path::Tiny|Path::Tiny>
  
  A minimalistic abstraction handling not only IO but also paths.
  
  =item * L<IO::All|IO::All>
  
  An attempt to expose as many IO related features as possible via a single API.
  
  =item * L<File::Slurp|File::Slurp>
  
  This is previous generation file slurping module. It has a number of issues, as described L<here|http://blogs.perl.org/users/leon_timmermans/2015/08/fileslurp-is-broken-and-wrong.html>
  
  =item * L<File::Slurp::Tiny|File::Slurp::Tiny>
  
  This was my previous attempt at a better file slurping module. It's mostly (but not entirely) a drop-in replacement for File::Slurp, which is both a feature (easy conversion) and a bug (interface issues).
  
  =back
  
  =head1 TODO
  
  =over 4
  
  =item * C<open_text>/C<open_binary>?
  
  =item * C<drain_handle>?
  
  =back
  
  =head1 AUTHOR
  
  Leon Timmermans <leont@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2014 by Leon Timmermans.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_SLURPER

$fatpacked{"Git.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GIT';
  =head1 NAME
  
  Git - Perl interface to the Git version control system
  
  =cut
  
  
  package Git;
  
  use 5.008;
  use strict;
  
  
  BEGIN {
  
  our ($VERSION, @ISA, @EXPORT, @EXPORT_OK);
  
  # Totally unstable API.
  $VERSION = '0.40';
  
  
  =head1 SYNOPSIS
  
    use Git;
  
    my $version = Git::command_oneline('version');
  
    git_cmd_try { Git::command_noisy('update-server-info') }
                '%s failed w/ code %d';
  
    my $repo = Git->repository (Directory => '/srv/git/cogito.git');
  
  
    my @revs = $repo->command('rev-list', '--since=last monday', '--all');
  
    my ($fh, $c) = $repo->command_output_pipe('rev-list', '--since=last monday', '--all');
    my $lastrev = <$fh>; chomp $lastrev;
    $repo->command_close_pipe($fh, $c);
  
    my $lastrev = $repo->command_oneline( [ 'rev-list', '--all' ],
                                          STDERR => 0 );
  
    my $sha1 = $repo->hash_and_insert_object('file.txt');
    my $tempfile = tempfile();
    my $size = $repo->cat_blob($sha1, $tempfile);
  
  =cut
  
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(git_cmd_try);
  
  # Methods which can be called as standalone functions as well:
  @EXPORT_OK = qw(command command_oneline command_noisy
                  command_output_pipe command_input_pipe command_close_pipe
                  command_bidi_pipe command_close_bidi_pipe
                  version exec_path html_path hash_object git_cmd_try
                  remote_refs prompt
                  get_tz_offset
                  credential credential_read credential_write
                  temp_acquire temp_is_locked temp_release temp_reset temp_path);
  
  
  =head1 DESCRIPTION
  
  This is the Git.pm from github's git/git, which is a mirror of the git source.
  I (cpan msouth, or current maintainer) update the VERSION string here, and 
  maintain this little bit of POD.  That's it.  The only reason you would
  need this is if you are using something like Git::Hooks and you are using
  a perlbrewed (or otherwise separate) perl from the one git is using on your
  system (e.g. if you have a dev perl that's separate from system perl and git
  uses the system perl.  Then the Git.pm gets installed in the system lib and you
  have no way of getting it from CPAN, so your code that uses modules that 
  depend on it doesn't work).  Except for this paragraph and the VERSION
  string, this is just a copy of the latests version of perl/Git.pm from 
  https://raw.github.com/git/git/master/perl/Git.pm .  Or, at least, it should
  be--let me know if it's out of date and I hadn't noticed.)
  
  This module provides Perl scripts easy way to interface the Git version control
  system. The modules have an easy and well-tested way to call arbitrary Git
  commands; in the future, the interface will also provide specialized methods
  for doing easily operations which are not totally trivial to do over
  the generic command interface.
  
  While some commands can be executed outside of any context (e.g. 'version'
  or 'init'), most operations require a repository context, which in practice
  means getting an instance of the Git object using the repository() constructor.
  (In the future, we will also get a new_repository() constructor.) All commands
  called as methods of the object are then executed in the context of the
  repository.
  
  Part of the "repository state" is also information about path to the attached
  working copy (unless you work with a bare repository). You can also navigate
  inside of the working copy using the C<wc_chdir()> method. (Note that
  the repository object is self-contained and will not change working directory
  of your process.)
  
  TODO: In the future, we might also do
  
  	my $remoterepo = $repo->remote_repository (Name => 'cogito', Branch => 'master');
  	$remoterepo ||= Git->remote_repository ('http://git.or.cz/cogito.git/');
  	my @refs = $remoterepo->refs();
  
  Currently, the module merely wraps calls to external Git tools. In the future,
  it will provide a much faster way to interact with Git by linking directly
  to libgit. This should be completely opaque to the user, though (performance
  increase notwithstanding).
  
  =cut
  
  
  use Carp qw(carp croak); # but croak is bad - throw instead
  use Error qw(:try);
  use Cwd qw(abs_path cwd);
  use IPC::Open2 qw(open2);
  use Fcntl qw(SEEK_SET SEEK_CUR);
  use Time::Local qw(timegm);
  }
  
  
  =head1 CONSTRUCTORS
  
  =over 4
  
  =item repository ( OPTIONS )
  
  =item repository ( DIRECTORY )
  
  =item repository ()
  
  Construct a new repository object.
  C<OPTIONS> are passed in a hash like fashion, using key and value pairs.
  Possible options are:
  
  B<Repository> - Path to the Git repository.
  
  B<WorkingCopy> - Path to the associated working copy; not strictly required
  as many commands will happily crunch on a bare repository.
  
  B<WorkingSubdir> - Subdirectory in the working copy to work inside.
  Just left undefined if you do not want to limit the scope of operations.
  
  B<Directory> - Path to the Git working directory in its usual setup.
  The C<.git> directory is searched in the directory and all the parent
  directories; if found, C<WorkingCopy> is set to the directory containing
  it and C<Repository> to the C<.git> directory itself. If no C<.git>
  directory was found, the C<Directory> is assumed to be a bare repository,
  C<Repository> is set to point at it and C<WorkingCopy> is left undefined.
  If the C<$GIT_DIR> environment variable is set, things behave as expected
  as well.
  
  You should not use both C<Directory> and either of C<Repository> and
  C<WorkingCopy> - the results of that are undefined.
  
  Alternatively, a directory path may be passed as a single scalar argument
  to the constructor; it is equivalent to setting only the C<Directory> option
  field.
  
  Calling the constructor with no options whatsoever is equivalent to
  calling it with C<< Directory => '.' >>. In general, if you are building
  a standard porcelain command, simply doing C<< Git->repository() >> should
  do the right thing and setup the object to reflect exactly where the user
  is right now.
  
  =cut
  
  sub repository {
  	my $class = shift;
  	my @args = @_;
  	my %opts = ();
  	my $self;
  
  	if (defined $args[0]) {
  		if ($#args % 2 != 1) {
  			# Not a hash.
  			$#args == 0 or throw Error::Simple("bad usage");
  			%opts = ( Directory => $args[0] );
  		} else {
  			%opts = @args;
  		}
  	}
  
  	if (not defined $opts{Repository} and not defined $opts{WorkingCopy}
  		and not defined $opts{Directory}) {
  		$opts{Directory} = '.';
  	}
  
  	if (defined $opts{Directory}) {
  		-d $opts{Directory} or throw Error::Simple("Directory not found: $opts{Directory} $!");
  
  		my $search = Git->repository(WorkingCopy => $opts{Directory});
  		my $dir;
  		try {
  			$dir = $search->command_oneline(['rev-parse', '--git-dir'],
  			                                STDERR => 0);
  		} catch Git::Error::Command with {
  			$dir = undef;
  		};
  
  		if ($dir) {
  			$dir =~ m#^/# or $dir = $opts{Directory} . '/' . $dir;
  			$opts{Repository} = abs_path($dir);
  
  			# If --git-dir went ok, this shouldn't die either.
  			my $prefix = $search->command_oneline('rev-parse', '--show-prefix');
  			$dir = abs_path($opts{Directory}) . '/';
  			if ($prefix) {
  				if (substr($dir, -length($prefix)) ne $prefix) {
  					throw Error::Simple("rev-parse confused me - $dir does not have trailing $prefix");
  				}
  				substr($dir, -length($prefix)) = '';
  			}
  			$opts{WorkingCopy} = $dir;
  			$opts{WorkingSubdir} = $prefix;
  
  		} else {
  			# A bare repository? Let's see...
  			$dir = $opts{Directory};
  
  			unless (-d "$dir/refs" and -d "$dir/objects" and -e "$dir/HEAD") {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  			my $search = Git->repository(Repository => $dir);
  			try {
  				$search->command('symbolic-ref', 'HEAD');
  			} catch Git::Error::Command with {
  				# Mimic git-rev-parse --git-dir error message:
  				throw Error::Simple("fatal: Not a git repository: $dir");
  			}
  
  			$opts{Repository} = abs_path($dir);
  		}
  
  		delete $opts{Directory};
  	}
  
  	$self = { opts => \%opts };
  	bless $self, $class;
  }
  
  =back
  
  =head1 METHODS
  
  =over 4
  
  =item command ( COMMAND [, ARGUMENTS... ] )
  
  =item command ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given Git C<COMMAND> (specify it without the 'git-'
  prefix), optionally with the specified extra C<ARGUMENTS>.
  
  The second more elaborate form can be used if you want to further adjust
  the command execution. Currently, only one option is supported:
  
  B<STDERR> - How to deal with the command's error output. By default (C<undef>)
  it is delivered to the caller's C<STDERR>. A false value (0 or '') will cause
  it to be thrown away. If you want to process it, you can get it in a filehandle
  you specify, but you must be extremely careful; if the error output is not
  very short and you want to read it in the same process as where you called
  C<command()>, you are set up for a nice deadlock!
  
  The method can be called without any instance or on a specified Git repository
  (in that case the command will be run in the repository context).
  
  In scalar context, it returns all the command output in a single string
  (verbatim).
  
  In array context, it returns an array containing lines printed to the
  command's stdout (without trailing newlines).
  
  In both cases, the command's stdin and stderr are the same as the caller's.
  
  =cut
  
  sub command {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	if (not defined wantarray) {
  		# Nothing to pepper the possible exception with.
  		_cmd_close($ctx, $fh);
  
  	} elsif (not wantarray) {
  		local $/;
  		my $text = <$fh>;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			# Pepper with the output:
  			my $E = shift;
  			$E->{'-outputref'} = \$text;
  			throw $E;
  		};
  		return $text;
  
  	} else {
  		my @lines = <$fh>;
  		defined and chomp for @lines;
  		try {
  			_cmd_close($ctx, $fh);
  		} catch Git::Error::Command with {
  			my $E = shift;
  			$E->{'-outputref'} = \@lines;
  			throw $E;
  		};
  		return @lines;
  	}
  }
  
  
  =item command_oneline ( COMMAND [, ARGUMENTS... ] )
  
  =item command_oneline ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but always return a scalar string containing the first line
  of the command's standard output.
  
  =cut
  
  sub command_oneline {
  	my ($fh, $ctx) = command_output_pipe(@_);
  
  	my $line = <$fh>;
  	defined $line and chomp $line;
  	try {
  		_cmd_close($ctx, $fh);
  	} catch Git::Error::Command with {
  		# Pepper with the output:
  		my $E = shift;
  		$E->{'-outputref'} = \$line;
  		throw $E;
  	};
  	return $line;
  }
  
  
  =item command_output_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_output_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command()
  does but return a pipe filehandle from which the command output can be
  read.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_output_pipe {
  	_command_common_pipe('-|', @_);
  }
  
  
  =item command_input_pipe ( COMMAND [, ARGUMENTS... ] )
  
  =item command_input_pipe ( [ COMMAND, ARGUMENTS... ], { Opt => Val ... } )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return an input pipe filehandle instead; the command output
  is not captured.
  
  The function can return C<($pipe, $ctx)> in array context.
  See C<command_close_pipe()> for details.
  
  =cut
  
  sub command_input_pipe {
  	_command_common_pipe('|-', @_);
  }
  
  
  =item command_close_pipe ( PIPE [, CTX ] )
  
  Close the C<PIPE> as returned from C<command_*_pipe()>, checking
  whether the command finished successfully. The optional C<CTX> argument
  is required if you want to see the command name in the error message,
  and it is the second value returned by C<command_*_pipe()> when
  called in array context. The call idiom is:
  
  	my ($fh, $ctx) = $r->command_output_pipe('status');
  	while (<$fh>) { ... }
  	$r->command_close_pipe($fh, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  =cut
  
  sub command_close_pipe {
  	my ($self, $fh, $ctx) = _maybe_self(@_);
  	$ctx ||= '<unknown>';
  	_cmd_close($ctx, $fh);
  }
  
  =item command_bidi_pipe ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command_output_pipe()
  does but return both an input pipe filehandle and an output pipe filehandle.
  
  The function will return return C<($pid, $pipe_in, $pipe_out, $ctx)>.
  See C<command_close_bidi_pipe()> for details.
  
  =cut
  
  sub command_bidi_pipe {
  	my ($pid, $in, $out);
  	my ($self) = _maybe_self(@_);
  	local %ENV = %ENV;
  	my $cwd_save = undef;
  	if ($self) {
  		shift;
  		$cwd_save = cwd();
  		_setup_git_cmd_env($self);
  	}
  	$pid = open2($in, $out, 'git', @_);
  	chdir($cwd_save) if $cwd_save;
  	return ($pid, $in, $out, join(' ', @_));
  }
  
  =item command_close_bidi_pipe ( PID, PIPE_IN, PIPE_OUT [, CTX] )
  
  Close the C<PIPE_IN> and C<PIPE_OUT> as returned from C<command_bidi_pipe()>,
  checking whether the command finished successfully. The optional C<CTX>
  argument is required if you want to see the command name in the error message,
  and it is the fourth value returned by C<command_bidi_pipe()>.  The call idiom
  is:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, $out, $ctx);
  
  Note that you should not rely on whatever actually is in C<CTX>;
  currently it is simply the command name but in future the context might
  have more complicated structure.
  
  C<PIPE_IN> and C<PIPE_OUT> may be C<undef> if they have been closed prior to
  calling this function.  This may be useful in a query-response type of
  commands where caller first writes a query and later reads response, eg:
  
  	my ($pid, $in, $out, $ctx) = $r->command_bidi_pipe('cat-file --batch-check');
  	print $out "000000000\n";
  	close $out;
  	while (<$in>) { ... }
  	$r->command_close_bidi_pipe($pid, $in, undef, $ctx);
  
  This idiom may prevent potential dead locks caused by data sent to the output
  pipe not being flushed and thus not reaching the executed command.
  
  =cut
  
  sub command_close_bidi_pipe {
  	local $?;
  	my ($self, $pid, $in, $out, $ctx) = _maybe_self(@_);
  	_cmd_close($ctx, (grep { defined } ($in, $out)));
  	waitpid $pid, 0;
  	if ($? >> 8) {
  		throw Git::Error::Command($ctx, $? >>8);
  	}
  }
  
  
  =item command_noisy ( COMMAND [, ARGUMENTS... ] )
  
  Execute the given C<COMMAND> in the same way as command() does but do not
  capture the command output - the standard output is not redirected and goes
  to the standard output of the caller application.
  
  While the method is called command_noisy(), you might want to as well use
  it for the most silent Git commands which you know will never pollute your
  stdout but you want to avoid the overhead of the pipe setup when calling them.
  
  The function returns only after the command has finished running.
  
  =cut
  
  sub command_noisy {
  	my ($self, $cmd, @args) = _maybe_self(@_);
  	_check_valid_cmd($cmd);
  
  	my $pid = fork;
  	if (not defined $pid) {
  		throw Error::Simple("fork failed: $!");
  	} elsif ($pid == 0) {
  		_cmd_exec($self, $cmd, @args);
  	}
  	if (waitpid($pid, 0) > 0 and $?>>8 != 0) {
  		throw Git::Error::Command(join(' ', $cmd, @args), $? >> 8);
  	}
  }
  
  
  =item version ()
  
  Return the Git version in use.
  
  =cut
  
  sub version {
  	my $verstr = command_oneline('--version');
  	$verstr =~ s/^git version //;
  	$verstr;
  }
  
  
  =item exec_path ()
  
  Return path to the Git sub-command executables (the same as
  C<git --exec-path>). Useful mostly only internally.
  
  =cut
  
  sub exec_path { command_oneline('--exec-path') }
  
  
  =item html_path ()
  
  Return path to the Git html documentation (the same as
  C<git --html-path>). Useful mostly only internally.
  
  =cut
  
  sub html_path { command_oneline('--html-path') }
  
  
  =item get_tz_offset ( TIME )
  
  Return the time zone offset from GMT in the form +/-HHMM where HH is
  the number of hours from GMT and MM is the number of minutes.  This is
  the equivalent of what strftime("%z", ...) would provide on a GNU
  platform.
  
  If TIME is not supplied, the current local time is used.
  
  =cut
  
  sub get_tz_offset {
  	# some systmes don't handle or mishandle %z, so be creative.
  	my $t = shift || time;
  	my $gm = timegm(localtime($t));
  	my $sign = qw( + + - )[ $gm <=> $t ];
  	return sprintf("%s%02d%02d", $sign, (gmtime(abs($t - $gm)))[2,1]);
  }
  
  
  =item prompt ( PROMPT , ISPASSWORD  )
  
  Query user C<PROMPT> and return answer from user.
  
  Honours GIT_ASKPASS and SSH_ASKPASS environment variables for querying
  the user. If no *_ASKPASS variable is set or an error occoured,
  the terminal is tried as a fallback.
  If C<ISPASSWORD> is set and true, the terminal disables echo.
  
  =cut
  
  sub prompt {
  	my ($prompt, $isPassword) = @_;
  	my $ret;
  	if (exists $ENV{'GIT_ASKPASS'}) {
  		$ret = _prompt($ENV{'GIT_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret && exists $ENV{'SSH_ASKPASS'}) {
  		$ret = _prompt($ENV{'SSH_ASKPASS'}, $prompt);
  	}
  	if (!defined $ret) {
  		print STDERR $prompt;
  		STDERR->flush;
  		if (defined $isPassword && $isPassword) {
  			require Term::ReadKey;
  			Term::ReadKey::ReadMode('noecho');
  			$ret = '';
  			while (defined(my $key = Term::ReadKey::ReadKey(0))) {
  				last if $key =~ /[\012\015]/; # \n\r
  				$ret .= $key;
  			}
  			Term::ReadKey::ReadMode('restore');
  			print STDERR "\n";
  			STDERR->flush;
  		} else {
  			chomp($ret = <STDIN>);
  		}
  	}
  	return $ret;
  }
  
  sub _prompt {
  	my ($askpass, $prompt) = @_;
  	return unless length $askpass;
  	$prompt =~ s/\n/ /g;
  	my $ret;
  	open my $fh, "-|", $askpass, $prompt or return;
  	$ret = <$fh>;
  	$ret =~ s/[\015\012]//g; # strip \r\n, chomp does not work on all systems (i.e. windows) as expected
  	close ($fh);
  	return $ret;
  }
  
  =item repo_path ()
  
  Return path to the git repository. Must be called on a repository instance.
  
  =cut
  
  sub repo_path { $_[0]->{opts}->{Repository} }
  
  
  =item wc_path ()
  
  Return path to the working copy. Must be called on a repository instance.
  
  =cut
  
  sub wc_path { $_[0]->{opts}->{WorkingCopy} }
  
  
  =item wc_subdir ()
  
  Return path to the subdirectory inside of a working copy. Must be called
  on a repository instance.
  
  =cut
  
  sub wc_subdir { $_[0]->{opts}->{WorkingSubdir} ||= '' }
  
  
  =item wc_chdir ( SUBDIR )
  
  Change the working copy subdirectory to work within. The C<SUBDIR> is
  relative to the working copy root directory (not the current subdirectory).
  Must be called on a repository instance attached to a working copy
  and the directory must exist.
  
  =cut
  
  sub wc_chdir {
  	my ($self, $subdir) = @_;
  	$self->wc_path()
  		or throw Error::Simple("bare repository");
  
  	-d $self->wc_path().'/'.$subdir
  		or throw Error::Simple("subdir not found: $subdir $!");
  	# Of course we will not "hold" the subdirectory so anyone
  	# can delete it now and we will never know. But at least we tried.
  
  	$self->{opts}->{WorkingSubdir} = $subdir;
  }
  
  
  =item config ( VARIABLE )
  
  Retrieve the configuration C<VARIABLE> in the same manner as C<config>
  does. In scalar context requires the variable to be set only one time
  (exception is thrown otherwise), in array context returns allows the
  variable to be set multiple times and returns all the values.
  
  =cut
  
  sub config {
  	return _config_common({}, @_);
  }
  
  
  =item config_bool ( VARIABLE )
  
  Retrieve the bool configuration C<VARIABLE>. The return value
  is usable as a boolean in perl (and C<undef> if it's not defined,
  of course).
  
  =cut
  
  sub config_bool {
  	my $val = scalar _config_common({'kind' => '--bool'}, @_);
  
  	# Do not rewrite this as return (defined $val && $val eq 'true')
  	# as some callers do care what kind of falsehood they receive.
  	if (!defined $val) {
  		return undef;
  	} else {
  		return $val eq 'true';
  	}
  }
  
  
  =item config_path ( VARIABLE )
  
  Retrieve the path configuration C<VARIABLE>. The return value
  is an expanded path or C<undef> if it's not defined.
  
  =cut
  
  sub config_path {
  	return _config_common({'kind' => '--path'}, @_);
  }
  
  
  =item config_int ( VARIABLE )
  
  Retrieve the integer configuration C<VARIABLE>. The return value
  is simple decimal number.  An optional value suffix of 'k', 'm',
  or 'g' in the config file will cause the value to be multiplied
  by 1024, 1048576 (1024^2), or 1073741824 (1024^3) prior to output.
  It would return C<undef> if configuration variable is not defined,
  
  =cut
  
  sub config_int {
  	return scalar _config_common({'kind' => '--int'}, @_);
  }
  
  # Common subroutine to implement bulk of what the config* family of methods
  # do. This curently wraps command('config') so it is not so fast.
  sub _config_common {
  	my ($opts) = shift @_;
  	my ($self, $var) = _maybe_self(@_);
  
  	try {
  		my @cmd = ('config', $opts->{'kind'} ? $opts->{'kind'} : ());
  		unshift @cmd, $self if $self;
  		if (wantarray) {
  			return command(@cmd, '--get-all', $var);
  		} else {
  			return command_oneline(@cmd, '--get', $var);
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		if ($E->value() == 1) {
  			# Key not found.
  			return;
  		} else {
  			throw $E;
  		}
  	};
  }
  
  =item get_colorbool ( NAME )
  
  Finds if color should be used for NAMEd operation from the configuration,
  and returns boolean (true for "use color", false for "do not use color").
  
  =cut
  
  sub get_colorbool {
  	my ($self, $var) = @_;
  	my $stdout_to_tty = (-t STDOUT) ? "true" : "false";
  	my $use_color = $self->command_oneline('config', '--get-colorbool',
  					       $var, $stdout_to_tty);
  	return ($use_color eq 'true');
  }
  
  =item get_color ( SLOT, COLOR )
  
  Finds color for SLOT from the configuration, while defaulting to COLOR,
  and returns the ANSI color escape sequence:
  
  	print $repo->get_color("color.interactive.prompt", "underline blue white");
  	print "some text";
  	print $repo->get_color("", "normal");
  
  =cut
  
  sub get_color {
  	my ($self, $slot, $default) = @_;
  	my $color = $self->command_oneline('config', '--get-color', $slot, $default);
  	if (!defined $color) {
  		$color = "";
  	}
  	return $color;
  }
  
  =item remote_refs ( REPOSITORY [, GROUPS [, REFGLOBS ] ] )
  
  This function returns a hashref of refs stored in a given remote repository.
  The hash is in the format C<refname =\> hash>. For tags, the C<refname> entry
  contains the tag object while a C<refname^{}> entry gives the tagged objects.
  
  C<REPOSITORY> has the same meaning as the appropriate C<git-ls-remote>
  argument; either a URL or a remote name (if called on a repository instance).
  C<GROUPS> is an optional arrayref that can contain 'tags' to return all the
  tags and/or 'heads' to return all the heads. C<REFGLOB> is an optional array
  of strings containing a shell-like glob to further limit the refs returned in
  the hash; the meaning is again the same as the appropriate C<git-ls-remote>
  argument.
  
  This function may or may not be called on a repository instance. In the former
  case, remote names as defined in the repository are recognized as repository
  specifiers.
  
  =cut
  
  sub remote_refs {
  	my ($self, $repo, $groups, $refglobs) = _maybe_self(@_);
  	my @args;
  	if (ref $groups eq 'ARRAY') {
  		foreach (@$groups) {
  			if ($_ eq 'heads') {
  				push (@args, '--heads');
  			} elsif ($_ eq 'tags') {
  				push (@args, '--tags');
  			} else {
  				# Ignore unknown groups for future
  				# compatibility
  			}
  		}
  	}
  	push (@args, $repo);
  	if (ref $refglobs eq 'ARRAY') {
  		push (@args, @$refglobs);
  	}
  
  	my @self = $self ? ($self) : (); # Ultra trickery
  	my ($fh, $ctx) = Git::command_output_pipe(@self, 'ls-remote', @args);
  	my %refs;
  	while (<$fh>) {
  		chomp;
  		my ($hash, $ref) = split(/\t/, $_, 2);
  		$refs{$ref} = $hash;
  	}
  	Git::command_close_pipe(@self, $fh, $ctx);
  	return \%refs;
  }
  
  
  =item ident ( TYPE | IDENTSTR )
  
  =item ident_person ( TYPE | IDENTSTR | IDENTARRAY )
  
  This suite of functions retrieves and parses ident information, as stored
  in the commit and tag objects or produced by C<var GIT_type_IDENT> (thus
  C<TYPE> can be either I<author> or I<committer>; case is insignificant).
  
  The C<ident> method retrieves the ident information from C<git var>
  and either returns it as a scalar string or as an array with the fields parsed.
  Alternatively, it can take a prepared ident string (e.g. from the commit
  object) and just parse it.
  
  C<ident_person> returns the person part of the ident - name and email;
  it can take the same arguments as C<ident> or the array returned by C<ident>.
  
  The synopsis is like:
  
  	my ($name, $email, $time_tz) = ident('author');
  	"$name <$email>" eq ident_person('author');
  	"$name <$email>" eq ident_person($name);
  	$time_tz =~ /^\d+ [+-]\d{4}$/;
  
  =cut
  
  sub ident {
  	my ($self, $type) = _maybe_self(@_);
  	my $identstr;
  	if (lc $type eq lc 'committer' or lc $type eq lc 'author') {
  		my @cmd = ('var', 'GIT_'.uc($type).'_IDENT');
  		unshift @cmd, $self if $self;
  		$identstr = command_oneline(@cmd);
  	} else {
  		$identstr = $type;
  	}
  	if (wantarray) {
  		return $identstr =~ /^(.*) <(.*)> (\d+ [+-]\d{4})$/;
  	} else {
  		return $identstr;
  	}
  }
  
  sub ident_person {
  	my ($self, @ident) = _maybe_self(@_);
  	$#ident == 0 and @ident = $self ? $self->ident($ident[0]) : ident($ident[0]);
  	return "$ident[0] <$ident[1]>";
  }
  
  
  =item hash_object ( TYPE, FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> considering it is
  of the C<TYPE> object type (C<blob>, C<commit>, C<tree>).
  
  The method can be called without any instance or on a specified Git repository,
  it makes zero difference.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_object {
  	my ($self, $type, $file) = _maybe_self(@_);
  	command_oneline('hash-object', '-t', $type, $file);
  }
  
  
  =item hash_and_insert_object ( FILENAME )
  
  Compute the SHA1 object id of the given C<FILENAME> and add the object to the
  object database.
  
  The function returns the SHA1 hash.
  
  =cut
  
  # TODO: Support for passing FILEHANDLE instead of FILENAME
  sub hash_and_insert_object {
  	my ($self, $filename) = @_;
  
  	carp "Bad filename \"$filename\"" if $filename =~ /[\r\n]/;
  
  	$self->_open_hash_and_insert_object_if_needed();
  	my ($in, $out) = ($self->{hash_object_in}, $self->{hash_object_out});
  
  	unless (print $out $filename, "\n") {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	chomp(my $hash = <$in>);
  	unless (defined($hash)) {
  		$self->_close_hash_and_insert_object();
  		throw Error::Simple("in pipe went bad");
  	}
  
  	return $hash;
  }
  
  sub _open_hash_and_insert_object_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{hash_object_pid});
  
  	($self->{hash_object_pid}, $self->{hash_object_in},
  	 $self->{hash_object_out}, $self->{hash_object_ctx}) =
  		$self->command_bidi_pipe(qw(hash-object -w --stdin-paths --no-filters));
  }
  
  sub _close_hash_and_insert_object {
  	my ($self) = @_;
  
  	return unless defined($self->{hash_object_pid});
  
  	my @vars = map { 'hash_object_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  =item cat_blob ( SHA1, FILEHANDLE )
  
  Prints the contents of the blob identified by C<SHA1> to C<FILEHANDLE> and
  returns the number of bytes printed.
  
  =cut
  
  sub cat_blob {
  	my ($self, $sha1, $fh) = @_;
  
  	$self->_open_cat_blob_if_needed();
  	my ($in, $out) = ($self->{cat_blob_in}, $self->{cat_blob_out});
  
  	unless (print $out $sha1, "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("out pipe went bad");
  	}
  
  	my $description = <$in>;
  	if ($description =~ / missing$/) {
  		carp "$sha1 doesn't exist in the repository";
  		return -1;
  	}
  
  	if ($description !~ /^[0-9a-fA-F]{40} \S+ (\d+)$/) {
  		carp "Unexpected result returned from git cat-file";
  		return -1;
  	}
  
  	my $size = $1;
  
  	my $blob;
  	my $bytesLeft = $size;
  
  	while (1) {
  		last unless $bytesLeft;
  
  		my $bytesToRead = $bytesLeft < 1024 ? $bytesLeft : 1024;
  		my $read = read($in, $blob, $bytesToRead);
  		unless (defined($read)) {
  			$self->_close_cat_blob();
  			throw Error::Simple("in pipe went bad");
  		}
  		unless (print $fh $blob) {
  			$self->_close_cat_blob();
  			throw Error::Simple("couldn't write to passed in filehandle");
  		}
  		$bytesLeft -= $read;
  	}
  
  	# Skip past the trailing newline.
  	my $newline;
  	my $read = read($in, $newline, 1);
  	unless (defined($read)) {
  		$self->_close_cat_blob();
  		throw Error::Simple("in pipe went bad");
  	}
  	unless ($read == 1 && $newline eq "\n") {
  		$self->_close_cat_blob();
  		throw Error::Simple("didn't find newline after blob");
  	}
  
  	return $size;
  }
  
  sub _open_cat_blob_if_needed {
  	my ($self) = @_;
  
  	return if defined($self->{cat_blob_pid});
  
  	($self->{cat_blob_pid}, $self->{cat_blob_in},
  	 $self->{cat_blob_out}, $self->{cat_blob_ctx}) =
  		$self->command_bidi_pipe(qw(cat-file --batch));
  }
  
  sub _close_cat_blob {
  	my ($self) = @_;
  
  	return unless defined($self->{cat_blob_pid});
  
  	my @vars = map { 'cat_blob_' . $_ } qw(pid in out ctx);
  
  	command_close_bidi_pipe(@$self{@vars});
  	delete @$self{@vars};
  }
  
  
  =item credential_read( FILEHANDLE )
  
  Reads credential key-value pairs from C<FILEHANDLE>.  Reading stops at EOF or
  when an empty line is encountered.  Each line must be of the form C<key=value>
  with a non-empty key.  Function returns hash with all read values.  Any white
  space (other than new-line character) is preserved.
  
  =cut
  
  sub credential_read {
  	my ($self, $reader) = _maybe_self(@_);
  	my %credential;
  	while (<$reader>) {
  		chomp;
  		if ($_ eq '') {
  			last;
  		} elsif (!/^([^=]+)=(.*)$/) {
  			throw Error::Simple("unable to parse git credential data:\n$_");
  		}
  		$credential{$1} = $2;
  	}
  	return %credential;
  }
  
  =item credential_write( FILEHANDLE, CREDENTIAL_HASHREF )
  
  Writes credential key-value pairs from hash referenced by
  C<CREDENTIAL_HASHREF> to C<FILEHANDLE>.  Keys and values cannot contain
  new-lines or NUL bytes characters, and key cannot contain equal signs nor be
  empty (if they do Error::Simple is thrown).  Any white space is preserved.  If
  value for a key is C<undef>, it will be skipped.
  
  If C<'url'> key exists it will be written first.  (All the other key-value
  pairs are written in sorted order but you should not depend on that).  Once
  all lines are written, an empty line is printed.
  
  =cut
  
  sub credential_write {
  	my ($self, $writer, $credential) = _maybe_self(@_);
  	my ($key, $value);
  
  	# Check if $credential is valid prior to writing anything
  	while (($key, $value) = each %$credential) {
  		if (!defined $key || !length $key) {
  			throw Error::Simple("credential key empty or undefined");
  		} elsif ($key =~ /[=\n\0]/) {
  			throw Error::Simple("credential key contains invalid characters: $key");
  		} elsif (defined $value && $value =~ /[\n\0]/) {
  			throw Error::Simple("credential value for key=$key contains invalid characters: $value");
  		}
  	}
  
  	for $key (sort {
  		# url overwrites other fields, so it must come first
  		return -1 if $a eq 'url';
  		return  1 if $b eq 'url';
  		return $a cmp $b;
  	} keys %$credential) {
  		if (defined $credential->{$key}) {
  			print $writer $key, '=', $credential->{$key}, "\n";
  		}
  	}
  	print $writer "\n";
  }
  
  sub _credential_run {
  	my ($self, $credential, $op) = _maybe_self(@_);
  	my ($pid, $reader, $writer, $ctx) = command_bidi_pipe('credential', $op);
  
  	credential_write $writer, $credential;
  	close $writer;
  
  	if ($op eq "fill") {
  		%$credential = credential_read $reader;
  	}
  	if (<$reader>) {
  		throw Error::Simple("unexpected output from git credential $op response:\n$_\n");
  	}
  
  	command_close_bidi_pipe($pid, $reader, undef, $ctx);
  }
  
  =item credential( CREDENTIAL_HASHREF [, OPERATION ] )
  
  =item credential( CREDENTIAL_HASHREF, CODE )
  
  Executes C<git credential> for a given set of credentials and specified
  operation.  In both forms C<CREDENTIAL_HASHREF> needs to be a reference to
  a hash which stores credentials.  Under certain conditions the hash can
  change.
  
  In the first form, C<OPERATION> can be C<'fill'>, C<'approve'> or C<'reject'>,
  and function will execute corresponding C<git credential> sub-command.  If
  it's omitted C<'fill'> is assumed.  In case of C<'fill'> the values stored in
  C<CREDENTIAL_HASHREF> will be changed to the ones returned by the C<git
  credential fill> command.  The usual usage would look something like:
  
  	my %cred = (
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	);
  	Git::credential \%cred;
  	if (try_to_authenticate($cred{'username'}, $cred{'password'})) {
  		Git::credential \%cred, 'approve';
  		... do more stuff ...
  	} else {
  		Git::credential \%cred, 'reject';
  	}
  
  In the second form, C<CODE> needs to be a reference to a subroutine.  The
  function will execute C<git credential fill> to fill the provided credential
  hash, then call C<CODE> with C<CREDENTIAL_HASHREF> as the sole argument.  If
  C<CODE>'s return value is defined, the function will execute C<git credential
  approve> (if return value yields true) or C<git credential reject> (if return
  value is false).  If the return value is undef, nothing at all is executed;
  this is useful, for example, if the credential could neither be verified nor
  rejected due to an unrelated network error.  The return value is the same as
  what C<CODE> returns.  With this form, the usage might look as follows:
  
  	if (Git::credential {
  		'protocol' => 'https',
  		'host' => 'example.com',
  		'username' => 'bob'
  	}, sub {
  		my $cred = shift;
  		return !!try_to_authenticate($cred->{'username'},
  		                             $cred->{'password'});
  	}) {
  		... do more stuff ...
  	}
  
  =cut
  
  sub credential {
  	my ($self, $credential, $op_or_code) = (_maybe_self(@_), 'fill');
  
  	if ('CODE' eq ref $op_or_code) {
  		_credential_run $credential, 'fill';
  		my $ret = $op_or_code->($credential);
  		if (defined $ret) {
  			_credential_run $credential, $ret ? 'approve' : 'reject';
  		}
  		return $ret;
  	} else {
  		_credential_run $credential, $op_or_code;
  	}
  }
  
  { # %TEMP_* Lexical Context
  
  my (%TEMP_FILEMAP, %TEMP_FILES);
  
  =item temp_acquire ( NAME )
  
  Attempts to retrieve the temporary file mapped to the string C<NAME>. If an
  associated temp file has not been created this session or was closed, it is
  created, cached, and set for autoflush and binmode.
  
  Internally locks the file mapped to C<NAME>. This lock must be released with
  C<temp_release()> when the temp file is no longer needed. Subsequent attempts
  to retrieve temporary files mapped to the same C<NAME> while still locked will
  cause an error. This locking mechanism provides a weak guarantee and is not
  threadsafe. It does provide some error checking to help prevent temp file refs
  writing over one another.
  
  In general, the L<File::Handle> returned should not be closed by consumers as
  it defeats the purpose of this caching mechanism. If you need to close the temp
  file handle, then you should use L<File::Temp> or another temp file faculty
  directly. If a handle is closed and then requested again, then a warning will
  issue.
  
  =cut
  
  sub temp_acquire {
  	my $temp_fd = _temp_cache(@_);
  
  	$TEMP_FILES{$temp_fd}{locked} = 1;
  	$temp_fd;
  }
  
  =item temp_is_locked ( NAME )
  
  Returns true if the internal lock created by a previous C<temp_acquire()>
  call with C<NAME> is still in effect.
  
  When temp_acquire is called on a C<NAME>, it internally locks the temporary
  file mapped to C<NAME>.  That lock will not be released until C<temp_release()>
  is called with either the original C<NAME> or the L<File::Handle> that was
  returned from the original call to temp_acquire.
  
  Subsequent attempts to call C<temp_acquire()> with the same C<NAME> will fail
  unless there has been an intervening C<temp_release()> call for that C<NAME>
  (or its corresponding L<File::Handle> that was returned by the original
  C<temp_acquire()> call).
  
  If true is returned by C<temp_is_locked()> for a C<NAME>, an attempt to
  C<temp_acquire()> the same C<NAME> will cause an error unless
  C<temp_release> is first called on that C<NAME> (or its corresponding
  L<File::Handle> that was returned by the original C<temp_acquire()> call).
  
  =cut
  
  sub temp_is_locked {
  	my ($self, $name) = _maybe_self(@_);
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  
  	defined $$temp_fd && $$temp_fd->opened && $TEMP_FILES{$$temp_fd}{locked};
  }
  
  =item temp_release ( NAME )
  
  =item temp_release ( FILEHANDLE )
  
  Releases a lock acquired through C<temp_acquire()>. Can be called either with
  the C<NAME> mapping used when acquiring the temp file or with the C<FILEHANDLE>
  referencing a locked temp file.
  
  Warns if an attempt is made to release a file that is not locked.
  
  The temp file will be truncated before being released. This can help to reduce
  disk I/O where the system is smart enough to detect the truncation while data
  is in the output buffers. Beware that after the temp file is released and
  truncated, any operations on that file may fail miserably until it is
  re-acquired. All contents are lost between each release and acquire mapped to
  the same string.
  
  =cut
  
  sub temp_release {
  	my ($self, $temp_fd, $trunc) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILES{$temp_fd};
  	}
  	unless ($TEMP_FILES{$temp_fd}{locked}) {
  		carp "Attempt to release temp file '",
  			$temp_fd, "' that has not been locked";
  	}
  	temp_reset($temp_fd) if $trunc and $temp_fd->opened;
  
  	$TEMP_FILES{$temp_fd}{locked} = 0;
  	undef;
  }
  
  sub _temp_cache {
  	my ($self, $name) = _maybe_self(@_);
  
  	_verify_require();
  
  	my $temp_fd = \$TEMP_FILEMAP{$name};
  	if (defined $$temp_fd and $$temp_fd->opened) {
  		if ($TEMP_FILES{$$temp_fd}{locked}) {
  			throw Error::Simple("Temp file with moniker '" .
  				$name . "' already in use");
  		}
  	} else {
  		if (defined $$temp_fd) {
  			# then we're here because of a closed handle.
  			carp "Temp file '", $name,
  				"' was closed. Opening replacement.";
  		}
  		my $fname;
  
  		my $tmpdir;
  		if (defined $self) {
  			$tmpdir = $self->repo_path();
  		}
  
  		($$temp_fd, $fname) = File::Temp::tempfile(
  			'Git_XXXXXX', UNLINK => 1, DIR => $tmpdir,
  			) or throw Error::Simple("couldn't open new temp file");
  
  		$$temp_fd->autoflush;
  		binmode $$temp_fd;
  		$TEMP_FILES{$$temp_fd}{fname} = $fname;
  	}
  	$$temp_fd;
  }
  
  sub _verify_require {
  	eval { require File::Temp; require File::Spec; };
  	$@ and throw Error::Simple($@);
  }
  
  =item temp_reset ( FILEHANDLE )
  
  Truncates and resets the position of the C<FILEHANDLE>.
  
  =cut
  
  sub temp_reset {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	truncate $temp_fd, 0
  		or throw Error::Simple("couldn't truncate file");
  	sysseek($temp_fd, 0, SEEK_SET) and seek($temp_fd, 0, SEEK_SET)
  		or throw Error::Simple("couldn't seek to beginning of file");
  	sysseek($temp_fd, 0, SEEK_CUR) == 0 and tell($temp_fd) == 0
  		or throw Error::Simple("expected file position to be reset");
  }
  
  =item temp_path ( NAME )
  
  =item temp_path ( FILEHANDLE )
  
  Returns the filename associated with the given tempfile.
  
  =cut
  
  sub temp_path {
  	my ($self, $temp_fd) = _maybe_self(@_);
  
  	if (exists $TEMP_FILEMAP{$temp_fd}) {
  		$temp_fd = $TEMP_FILEMAP{$temp_fd};
  	}
  	$TEMP_FILES{$temp_fd}{fname};
  }
  
  sub END {
  	unlink values %TEMP_FILEMAP if %TEMP_FILEMAP;
  }
  
  } # %TEMP_* Lexical Context
  
  =back
  
  =head1 ERROR HANDLING
  
  All functions are supposed to throw Perl exceptions in case of errors.
  See the L<Error> module on how to catch those. Most exceptions are mere
  L<Error::Simple> instances.
  
  However, the C<command()>, C<command_oneline()> and C<command_noisy()>
  functions suite can throw C<Git::Error::Command> exceptions as well: those are
  thrown when the external command returns an error code and contain the error
  code as well as access to the captured command's output. The exception class
  provides the usual C<stringify> and C<value> (command's exit code) methods and
  in addition also a C<cmd_output> method that returns either an array or a
  string with the captured command output (depending on the original function
  call context; C<command_noisy()> returns C<undef>) and $<cmdline> which
  returns the command and its arguments (but without proper quoting).
  
  Note that the C<command_*_pipe()> functions cannot throw this exception since
  it has no idea whether the command failed or not. You will only find out
  at the time you C<close> the pipe; if you want to have that automated,
  use C<command_close_pipe()>, which can throw the exception.
  
  =cut
  
  {
  	package Git::Error::Command;
  
  	@Git::Error::Command::ISA = qw(Error);
  
  	sub new {
  		my $self = shift;
  		my $cmdline = '' . shift;
  		my $value = 0 + shift;
  		my $outputref = shift;
  		my(@args) = ();
  
  		local $Error::Depth = $Error::Depth + 1;
  
  		push(@args, '-cmdline', $cmdline);
  		push(@args, '-value', $value);
  		push(@args, '-outputref', $outputref);
  
  		$self->SUPER::new(-text => 'command returned error', @args);
  	}
  
  	sub stringify {
  		my $self = shift;
  		my $text = $self->SUPER::stringify;
  		$self->cmdline() . ': ' . $text . ': ' . $self->value() . "\n";
  	}
  
  	sub cmdline {
  		my $self = shift;
  		$self->{'-cmdline'};
  	}
  
  	sub cmd_output {
  		my $self = shift;
  		my $ref = $self->{'-outputref'};
  		defined $ref or undef;
  		if (ref $ref eq 'ARRAY') {
  			return @$ref;
  		} else { # SCALAR
  			return $$ref;
  		}
  	}
  }
  
  =over 4
  
  =item git_cmd_try { CODE } ERRMSG
  
  This magical statement will automatically catch any C<Git::Error::Command>
  exceptions thrown by C<CODE> and make your program die with C<ERRMSG>
  on its lips; the message will have %s substituted for the command line
  and %d for the exit status. This statement is useful mostly for producing
  more user-friendly error messages.
  
  In case of no exception caught the statement returns C<CODE>'s return value.
  
  Note that this is the only auto-exported function.
  
  =cut
  
  sub git_cmd_try(&$) {
  	my ($code, $errmsg) = @_;
  	my @result;
  	my $err;
  	my $array = wantarray;
  	try {
  		if ($array) {
  			@result = &$code;
  		} else {
  			$result[0] = &$code;
  		}
  	} catch Git::Error::Command with {
  		my $E = shift;
  		$err = $errmsg;
  		$err =~ s/\%s/$E->cmdline()/ge;
  		$err =~ s/\%d/$E->value()/ge;
  		# We can't croak here since Error.pm would mangle
  		# that to Error::Simple.
  	};
  	$err and croak $err;
  	return $array ? @result : $result[0];
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright 2006 by Petr Baudis E<lt>pasky@suse.czE<gt>.
  
  This module is free software; it may be used, copied, modified
  and distributed under the terms of the GNU General Public Licence,
  either version 2, or (at your option) any later version.
  
  =cut
  
  
  # Take raw method argument list and return ($obj, @args) in case
  # the method was called upon an instance and (undef, @args) if
  # it was called directly.
  sub _maybe_self {
  	UNIVERSAL::isa($_[0], 'Git') ? @_ : (undef, @_);
  }
  
  # Check if the command id is something reasonable.
  sub _check_valid_cmd {
  	my ($cmd) = @_;
  	$cmd =~ /^[a-z0-9A-Z_-]+$/ or throw Error::Simple("bad command: $cmd");
  }
  
  # Common backend for the pipe creators.
  sub _command_common_pipe {
  	my $direction = shift;
  	my ($self, @p) = _maybe_self(@_);
  	my (%opts, $cmd, @args);
  	if (ref $p[0]) {
  		($cmd, @args) = @{shift @p};
  		%opts = ref $p[0] ? %{$p[0]} : @p;
  	} else {
  		($cmd, @args) = @p;
  	}
  	_check_valid_cmd($cmd);
  
  	my $fh;
  	if ($^O eq 'MSWin32') {
  		# ActiveState Perl
  		#defined $opts{STDERR} and
  		#	warn 'ignoring STDERR option - running w/ ActiveState';
  		$direction eq '-|' or
  			die 'input pipe for ActiveState not implemented';
  		# the strange construction with *ACPIPE is just to
  		# explain the tie below that we want to bind to
  		# a handle class, not scalar. It is not known if
  		# it is something specific to ActiveState Perl or
  		# just a Perl quirk.
  		tie (*ACPIPE, 'Git::activestate_pipe', $cmd, @args);
  		$fh = *ACPIPE;
  
  	} else {
  		my $pid = open($fh, $direction);
  		if (not defined $pid) {
  			throw Error::Simple("open failed: $!");
  		} elsif ($pid == 0) {
  			if ($opts{STDERR}) {
  				open (STDERR, '>&', $opts{STDERR})
  					or die "dup failed: $!";
  			} elsif (defined $opts{STDERR}) {
  				open (STDERR, '>', '/dev/null')
  					or die "opening /dev/null failed: $!";
  			}
  			_cmd_exec($self, $cmd, @args);
  		}
  	}
  	return wantarray ? ($fh, join(' ', $cmd, @args)) : $fh;
  }
  
  # When already in the subprocess, set up the appropriate state
  # for the given repository and execute the git command.
  sub _cmd_exec {
  	my ($self, @args) = @_;
  	_setup_git_cmd_env($self);
  	_execv_git_cmd(@args);
  	die qq[exec "@args" failed: $!];
  }
  
  # set up the appropriate state for git command
  sub _setup_git_cmd_env {
  	my $self = shift;
  	if ($self) {
  		$self->repo_path() and $ENV{'GIT_DIR'} = $self->repo_path();
  		$self->repo_path() and $self->wc_path()
  			and $ENV{'GIT_WORK_TREE'} = $self->wc_path();
  		$self->wc_path() and chdir($self->wc_path());
  		$self->wc_subdir() and chdir($self->wc_subdir());
  	}
  }
  
  # Execute the given Git command ($_[0]) with arguments ($_[1..])
  # by searching for it at proper places.
  sub _execv_git_cmd { exec('git', @_); }
  
  # Close pipe to a subprocess.
  sub _cmd_close {
  	my $ctx = shift @_;
  	foreach my $fh (@_) {
  		if (close $fh) {
  			# nop
  		} elsif ($!) {
  			# It's just close, no point in fatalities
  			carp "error closing pipe: $!";
  		} elsif ($? >> 8) {
  			# The caller should pepper this.
  			throw Git::Error::Command($ctx, $? >> 8);
  		}
  		# else we might e.g. closed a live stream; the command
  		# dying of SIGPIPE would drive us here.
  	}
  }
  
  
  sub DESTROY {
  	my ($self) = @_;
  	$self->_close_hash_and_insert_object();
  	$self->_close_cat_blob();
  }
  
  
  # Pipe implementation for ActiveState Perl.
  
  package Git::activestate_pipe;
  use strict;
  
  sub TIEHANDLE {
  	my ($class, @params) = @_;
  	# FIXME: This is probably horrible idea and the thing will explode
  	# at the moment you give it arguments that require some quoting,
  	# but I have no ActiveState clue... --pasky
  	# Let's just hope ActiveState Perl does at least the quoting
  	# correctly.
  	my @data = qx{git @params};
  	bless { i => 0, data => \@data }, $class;
  }
  
  sub READLINE {
  	my $self = shift;
  	if ($self->{i} >= scalar @{$self->{data}}) {
  		return undef;
  	}
  	my $i = $self->{i};
  	if (wantarray) {
  		$self->{i} = $#{$self->{'data'}} + 1;
  		return splice(@{$self->{'data'}}, $i);
  	}
  	$self->{i} = $i + 1;
  	return $self->{'data'}->[ $i ];
  }
  
  sub CLOSE {
  	my $self = shift;
  	delete $self->{data};
  	delete $self->{i};
  }
  
  sub EOF {
  	my $self = shift;
  	return ($self->{i} >= scalar @{$self->{data}});
  }
  
  
  1; # Famous last words
GIT

$fatpacked{"GitHub/Actions.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'GITHUB_ACTIONS';
  package GitHub::Actions;
  
  use Exporter 'import'; # needed to use @EXPORT
  use warnings;
  use strict;
  use Carp;
  
  use v5.14;
  
  # Module implementation here
  our %github;
  our $EXIT_CODE = 0;
  
  our @EXPORT = qw( %github set_output set_env debug error warning set_failed command_on_file error_on_file warning_on_file start_group end_group exit_action);
  
  BEGIN {
    for my $k ( keys(%ENV) ) {
      if ( $k =~ /^GITHUB_/ ) {
        my ($nogithub) = ( $k =~ /^GITHUB_(\w+)/ );
        $github{$nogithub} = $ENV{$k} ;
      }
    }
  }
  
  use version; our $VERSION = qv('0.1.1.1');
  
  sub set_output {
    carp "Need name and value" unless @_;
    my ($output_name, $output_value) = @_;
    $output_value ||='';
    say "::set-output name=$output_name\::$output_value";
  }
  
  sub set_env {
    my ($env_var_name, $env_var_value) = @_;
    open(my $fh, '>>', $github{'ENV'}) or die "Could not open file ". $github{'ENV'} ." $!";
    say $fh "$env_var_name=$env_var_value";
    close $fh;
  }
  
  sub debug {
    my $debug_message = shift;
    say "::debug::$debug_message";
  }
  
  sub error {
    my $error_message = shift;
    $EXIT_CODE = 1;
    say "::error::$error_message"
  }
  
  sub warning {
    my $warning = shift;
    say "::warning::$warning"
  }
  
  sub error_on_file {
    command_on_file( "::error", @_ );
  }
  
  sub warning_on_file {
    command_on_file( "::warning", @_ );
  }
  
  sub command_on_file {
    my $command = shift;
    my $message = shift;
    my ($file, $line, $col ) = @_;
    if ( $file ) {
      my @data;
      push( @data, "file=$file");
      push( @data, "line=$line") if $line;
      push( @data, "col=$col") if $col;
      $command .= " ".join(",", @data );
    }
    say $command."::$message"
  }
  
  sub start_group {
    say "::group::" . shift;
  }
  
  sub end_group {
    say "::endgroup::";
  }
  
  sub set_failed {
    error( @_ );
    exit( 1);
  }
  
  sub exit_action {
    exit( $EXIT_CODE );
  }
  
  "Action!"; # Magic true value required at end of module
  __END__
  
  =head1 NAME
  
  GitHub::Actions - Work in GitHub Actions using Perl
  
  
  =head1 VERSION
  
  This document describes GitHub::Actions version 0.1.1.1
  
  
  =head1 SYNOPSIS
  
      use GitHub::Actions;
      use v5.14;
  
      # %github contains all GITHUB_* environment variables
      for my $g (keys %github ) {
         say "GITHUB_$g -> ", $github{$g}
      }
  
      # Set step output
      set_output("FOO", "BAR");
  
      # Set environment variable value
      set_env("FOO", "BAR");
  
      # Produces an error and sets exit code to 1
      error( "FOO has happened" )
  
      # Exits with error if that's the case
      exit_action();
  
  Install this module within a GitHub action
  
        . name: "Install GitHub::Actions"
          run: sudo cpan GitHub::Actions
  
  (we need C<sudo> since we're using the system Perl)
  
  You can use this as a C<step>
  
        - name: Test env variables
          shell: perl {0}
          run: |
            use GitHub::Actions;
            set_env( 'FOO', 'BAR');
  
  In most cases, you'll want to just have it installed locally and fatpack it to
  upload it to the repository.
  
  =head1 DESCRIPTION
  
  GitHub Actions include by default, at least in its Linux runners, a
  system Perl which you can use directly in your GitHub actions. This here is
  a (for the time being) minimalistic module that tries to help a bit
  with that, by defining a few functions that will be useful when
  performing GitHub actions. Besides the system Perl, you can use any of
  L<the modules
  installed|https://gist.github.com/JJ/edf3a39d68525439978da2a02763d42b>. You
  can install other modules via cpan or, preferably for speed, via the
  Ubuntu package (or equivalent)
  
  Check out an example of using it in the L<repository|https://github.com/JJ/perl-GitHub-Actions/blob/main/.github/workflows/self-test.yml>
  
  =head1 INTERFACE
  
  =head2 set_env( $env_var_name, $env_var_value)
  
  This is equivalent to
  L<setting an environment variable|https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-an-environment-variable>
  
  =head2 set_output( $output_name, $output_value)
  
  Equivalent to L<C<set_output>|https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-an-output-parameter>
  
  =head2 debug( $debug_message )
  
  Equivalent to L<C<debug>|https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-a-debug-message>
  
  =head2 error( $error_message )
  
  Equivalent to
  L<C<error>|https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-an-error-message>,
  prints an error message. Remember to call L<exit_action()> to make the step fail
  if there's been some error.
  
  =head2 warning( $warning_message )
  
  Equivalent to L<C<warning>|https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-a-warning-message>, simply prints a warning.
  
  =head2 command_on_file( $error_message, $file, $line, $col )
  
  Common code for L<error_on_file> and L<warning_on_file>. Can be used for any future commands.
  
  =head2 error_on_file( $error_message, $file, $line, $col )
  
  Equivalent to L<C<error>|https://docs.github.com/en/free-pro-team@latest/actions/reference/workflow-commands-for-github-actions#setting-an-error-message>, prints an error message with file and line info
  
  =head2 warning_on_file( $warning_message, $file, $line, $col )
  
  Equivalent to L<C<warning>|https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#setting-a-warning-message>, prints an warning with file and line info.
  
  =head2 set_failed( $error_message )
  
  Exits with an error status of 1 after setting the error message.
  
  =head2 start_group( $group_name )
  
  Starts a group in the logs, grouping the following messages. Corresponds to
  L<C<group>|https://docs.github.com/en/actions/reference/workflow-commands-for-github-actions#grouping-log-lines>.
  
  =head2 end_group
  
  Ends current log grouping.
  
  =head2 exit_action
  
  Exits with the exit code generated during run, that is, 1 if there's been any
  error reported.
  
  =head1 CONFIGURATION AND ENVIRONMENT
  
  GitHub::Actions requires no configuration files or environment
  variables. Those set by GitHub Actions will only be available there,
  or if you set them explicitly. Remember that they will need to be set
  during the C<BEGIN> phase to be available when this module loads.
  
      BEGIN {
        $ENV{'GITHUB_FOO'} = 'foo';
        $ENV{'GITHUB_BAR'} = 'bar';
      }
  
  
  =head1 DEPENDENCIES
  
  Intentionally, no dependencies are included.
  
  
  =head1 INCOMPATIBILITIES
  
  None reported.
  
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  Please report any bugs or feature requests to L<https://github.com/JJ/perl-GitHub-Actions/issues>.
  
  
  =head1 AUTHOR
  
  JJ Merelo  C<< <jmerelo@CPAN.org> >>. Many thanks to RENEEB and Gabor Szabo for their help with test and metadata.
  
  
  =head1 LICENCE AND COPYRIGHT
  
  Copyright (c) 2021, JJ Merelo C<< <jmerelo@CPAN.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself. See L<perlartistic>.
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
GITHUB_ACTIONS

$fatpacked{"Utility.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'UTILITY';
  use GitHub::Actions;
  
  # Imprime cabeceras de objetivo/hito, principalmente
  sub doing {
    my $what = shift;
    start_group "\t Comprobando $what\n";
  }
  
  # Cuando los tets van bien
  sub all_good {
    return " " . shift
  }
  
  
  # Cuando fallan
  sub sorry {
    return " " . shift
  }
  
  "Yay"
UTILITY

$fatpacked{"YAML.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML';
  package YAML;
  our $VERSION = '1.13';
  
  use YAML::Mo;
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
YAML

$fatpacked{"YAML/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ANY';
  use strict; use warnings;
  package YAML::Any;
  our $VERSION = '1.13';
  
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      no warnings 'once';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::croak(@_);
  }
  
  1;
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER';
  package YAML::Dumper;
  
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo);
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0],
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) =
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      require YAML;
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} =
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) =
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash.
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
  
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 0 if $_[0] eq '-';
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  
  use YAML::Mo;
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
  
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_ERROR';
  package YAML::Error;
  
  use YAML::Mo;
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)}
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
       YAML_PARSE_ERR_NO_ANCHOR
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER';
  package YAML::Loader;
  
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';
  my $LIT_CHAR_RX = "\\$LIT_CHAR";
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS')
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE')
        if length($self->stream) and
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) =
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) =
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE');
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface);
  }
  
  # Morph a node to it's explicit type
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
  
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
  
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      # https://rt.cpan.org/Public/Bug/Display.html?id=90593
      if ($self->inline =~ /^"((?:(?:\\"|[^"]){0,32766}){0,32766})"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:(?:''|[^']){0,32766}){0,32766})'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or
                  $self->die('YAML_PARSE_ERR_NONSPACE_INDENTATION');
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
  
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos;
  
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
  
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  
  use YAML::Mo;
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MARSHALL';
  use strict; use warnings;
  package YAML::Marshall;
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_MO';
  package YAML::Mo; $VERSION = '0.88';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_NODE';
  use strict; use warnings;
  package YAML::Node;
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
          $self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
          $self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
          $self = tied(*{$_[0]});
      }
      else {
          $self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
                      ($type eq 'HASH') ? 'mapping' :
                      $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
          yaml_scalar->new($self, $_[1]);
          return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{TAG} = YAML::Tag->new($value);
          return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
                 $self->{KEYS} = $value;
          return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}};
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
          return (grep {$_ eq $key} @{$self->{KEYS}})
                 ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
          $self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
          $self->{HASH}{$key} = $value;
      }
      else {
          if (not grep {$_ eq $key} @{$self->{KEYS}}) {
              push(@{$self->{KEYS}}, $key);
          }
          $self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
          $return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
          $return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
          if ($self->{KEYS}[$i] eq $key) {
              splice(@{$self->{KEYS}}, $i, 1);
          }
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TAG';
  use strict; use warnings;
  package YAML::Tag;
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
YAML_TAG

$fatpacked{"YAML/Types.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_TYPES';
  package YAML::Types;
  
  use YAML::Mo;
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      }
      elsif ($type eq 'GLOB') {
          # blessed glob support is minimal, and will not round-trip
          # initial aim: to not cause an error
          return YAML::Type::glob->yaml_dump($value, $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      # $_[0] remains as the glob
      my $tag = pop @_ if 2==@_;
  
      $tag = '!perl/glob:' unless defined $tag;
      my $ynode = YAML::Node->new({}, $tag);
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value;
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0;
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
YAML_TYPES

$fatpacked{"x86_64-linux/List/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL';
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package List::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA        = qw(Exporter);
  our @EXPORT_OK  = qw(
    all any first min max minstr maxstr none notall product reduce sum sum0 shuffle uniq uniqnum uniqstr
    pairs unpairs pairkeys pairvalues pairmap pairgrep pairfirst
  );
  our $VERSION    = "1.49";
  our $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  require XSLoader;
  XSLoader::load('List::Util', $XS_VERSION);
  
  sub import
  {
    my $pkg = caller;
  
    # (RT88848) Touch the caller's $a and $b, to avoid the warning of
    #   Name "main::a" used only once: possible typo" warning
    no strict 'refs';
    ${"${pkg}::a"} = ${"${pkg}::a"};
    ${"${pkg}::b"} = ${"${pkg}::b"};
  
    goto &Exporter::import;
  }
  
  # For objects returned by pairs()
  sub List::Util::_Pair::key   { shift->[0] }
  sub List::Util::_Pair::value { shift->[1] }
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(
        reduce any all none notall first
  
        max maxstr min minstr product sum sum0
  
        pairs unpairs pairkeys pairvalues pairfirst pairgrep pairmap
  
        shuffle uniq uniqnum uniqstr
      );
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size so small such that being
  individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines.
  
  =cut
  
  =head1 LIST-REDUCTION FUNCTIONS
  
  The following set of functions all reduce a list down to a single value.
  
  =cut
  
  =head2 reduce
  
      $result = reduce { BLOCK } @list
  
  Reduces C<@list> by calling C<BLOCK> in a scalar context multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a> and C<$b>
  set to the first two elements of the list, subsequent calls will be done by
  setting C<$a> to the result of the previous call and C<$b> to the next element
  in the list.
  
  Returns the result of the last call to the C<BLOCK>. If C<@list> is empty then
  C<undef> is returned. If C<@list> only contains one element then that element
  is returned and C<BLOCK> is not executed.
  
  The following examples all demonstrate how C<reduce> could be used to implement
  the other list-reduction functions in this module. (They are not in fact
  implemented like this, but instead in a more efficient manner in individual C
  functions).
  
      $foo = reduce { defined($a)            ? $a :
                      $code->(local $_ = $b) ? $b :
                                               undef } undef, @list # first
  
      $foo = reduce { $a > $b ? $a : $b } 1..10       # max
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'   # maxstr
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
      $foo = reduce { $a || $code->(local $_ = $b) } 0, @bar   # any
      $foo = reduce { $a && $code->(local $_ = $b) } 1, @bar   # all
      $foo = reduce { $a && !$code->(local $_ = $b) } 1, @bar  # none
      $foo = reduce { $a || !$code->(local $_ = $b) } 0, @bar  # notall
         # Note that these implementations do not fully short-circuit
  
  If your algorithm requires that C<reduce> produce an identity value, then make
  sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  The above example code blocks also suggest how to use C<reduce> to build a
  more efficient combined version of one of these basic functions and a C<map>
  block. For example, to find the total length of all the strings in a list,
  we could use
  
      $total = sum map { length } @strings;
  
  However, this produces a list of temporary integer values as long as the
  original list of strings, only to reduce it down to a single value again. We
  can compute the same result more efficiently by using C<reduce> with a code
  block that accumulates lengths by writing this instead as:
  
      $total = reduce { $a + length $b } 0, @strings
  
  The remaining list-reduction functions are all specialisations of this generic
  idea.
  
  =head2 any
  
      my $bool = any { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<any> returns true if any element makes the C<BLOCK>
  return a true value. If C<BLOCK> never returns true or C<@list> was empty then
  it returns false.
  
  Many cases of using C<grep> in a conditional can be written using C<any>
  instead, as it can short-circuit after the first true result.
  
      if( any { length > 10 } @strings ) {
          # at least one string has more than 10 characters
      }
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 all
  
      my $bool = all { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any>, except that it requires all elements of the C<@list> to
  make the C<BLOCK> return true. If any element returns false, then it returns
  false. If the C<BLOCK> never returns false or the C<@list> was empty then it
  returns true.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 none
  
  =head2 notall
  
      my $bool = none { BLOCK } @list;
  
      my $bool = notall { BLOCK } @list;
  
  I<Since version 1.33.>
  
  Similar to L</any> and L</all>, but with the return sense inverted. C<none>
  returns true only if no value in the C<@list> causes the C<BLOCK> to return
  true, and C<notall> returns true only if not all of the values do.
  
  Note: Due to XS issues the block passed may be able to access the outer @_
  directly. This is not intentional and will break under debugger.
  
  =head2 first
  
      my $val = first { BLOCK } @list;
  
  Similar to C<grep> in that it evaluates C<BLOCK> setting C<$_> to each element
  of C<@list> in turn. C<first> returns the first element where the result from
  C<BLOCK> is a true value. If C<BLOCK> never returns true or C<@list> was empty
  then C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  =head2 max
  
      my $num = max @list;
  
  Returns the entry in the list with the highest numerical value. If the list is
  empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  =head2 maxstr
  
      my $str = maxstr @list;
  
  Similar to L</max>, but treats all the entries in the list as strings and
  returns the highest string as defined by the C<gt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  =head2 min
  
      my $num = min @list;
  
  Similar to L</max> but returns the entry in the list with the lowest numerical
  value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  =head2 minstr
  
      my $str = minstr @list;
  
  Similar to L</min>, but treats all the entries in the list as strings and
  returns the lowest string as defined by the C<lt> operator. If the list is
  empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  =head2 product
  
      my $num = product @list;
  
  I<Since version 1.35.>
  
  Returns the numerical product of all the elements in C<@list>. If C<@list> is
  empty then C<1> is returned.
  
      $foo = product 1..10            # 3628800
      $foo = product 3,9,12           # 324
  
  =head2 sum
  
      my $num_or_undef = sum @list;
  
  Returns the numerical sum of all the elements in C<@list>. For backwards
  compatibility, if C<@list> is empty then C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  =head2 sum0
  
      my $num = sum0 @list;
  
  I<Since version 1.26.>
  
  Similar to L</sum>, except this returns 0 when given an empty list, rather
  than C<undef>.
  
  =cut
  
  =head1 KEY/VALUE PAIR LIST FUNCTIONS
  
  The following set of functions, all inspired by L<List::Pairwise>, consume an
  even-sized list of pairs. The pairs may be key/value associations from a hash,
  or just a list of values. The functions will all preserve the original ordering
  of the pairs, and will not be confused by multiple pairs having the same "key"
  value - nor even do they require that the first of each pair be a plain string.
  
  B<NOTE>: At the time of writing, the following C<pair*> functions that take a
  block do not modify the value of C<$_> within the block, and instead operate
  using the C<$a> and C<$b> globals instead. This has turned out to be a poor
  design, as it precludes the ability to provide a C<pairsort> function. Better
  would be to pass pair-like objects as 2-element array references in C<$_>, in
  a style similar to the return value of the C<pairs> function. At some future
  version this behaviour may be added.
  
  Until then, users are alerted B<NOT> to rely on the value of C<$_> remaining
  unmodified between the outside and the inside of the control block. In
  particular, the following example is B<UNSAFE>:
  
   my @kvlist = ...
  
   foreach (qw( some keys here )) {
      my @items = pairgrep { $a eq $_ } @kvlist;
      ...
   }
  
  Instead, write this using a lexical variable:
  
   foreach my $key (qw( some keys here )) {
      my @items = pairgrep { $a eq $key } @kvlist;
      ...
   }
  
  =cut
  
  =head2 pairs
  
      my @pairs = pairs @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of C<ARRAY> references, each containing two items from the
  given list. It is a more efficient version of
  
      @pairs = pairmap { [ $a, $b ] } @kvlist
  
  It is most convenient to use in a C<foreach> loop, for example:
  
      foreach my $pair ( pairs @kvlist ) {
         my ( $key, $value ) = @$pair;
         ...
      }
  
  Since version C<1.39> these C<ARRAY> references are blessed objects,
  recognising the two methods C<key> and C<value>. The following code is
  equivalent:
  
      foreach my $pair ( pairs @kvlist ) {
         my $key   = $pair->key;
         my $value = $pair->value;
         ...
      }
  
  =head2 unpairs
  
      my @kvlist = unpairs @pairs
  
  I<Since version 1.42.>
  
  The inverse function to C<pairs>; this function takes a list of C<ARRAY>
  references containing two elements each, and returns a flattened list of the
  two values from each of the pairs, in order. This is notionally equivalent to
  
      my @kvlist = map { @{$_}[0,1] } @pairs
  
  except that it is implemented more efficiently internally. Specifically, for
  any input item it will extract exactly two values for the output list; using
  C<undef> if the input array references are short.
  
  Between C<pairs> and C<unpairs>, a higher-order list function can be used to
  operate on the pairs as single scalars; such as the following near-equivalents
  of the other C<pair*> higher-order functions:
  
      @kvlist = unpairs grep { FUNC } pairs @kvlist
      # Like pairgrep, but takes $_ instead of $a and $b
  
      @kvlist = unpairs map { FUNC } pairs @kvlist
      # Like pairmap, but takes $_ instead of $a and $b
  
  Note however that these versions will not behave as nicely in scalar context.
  
  Finally, this technique can be used to implement a sort on a keyvalue pair
  list; e.g.:
  
      @kvlist = unpairs sort { $a->key cmp $b->key } pairs @kvlist
  
  =head2 pairkeys
  
      my @keys = pairkeys @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the first values of each of the pairs in the given list.
  It is a more efficient version of
  
      @keys = pairmap { $a } @kvlist
  
  =head2 pairvalues
  
      my @values = pairvalues @kvlist;
  
  I<Since version 1.29.>
  
  A convenient shortcut to operating on even-sized lists of pairs, this function
  returns a list of the the second values of each of the pairs in the given list.
  It is a more efficient version of
  
      @values = pairmap { $b } @kvlist
  
  =head2 pairgrep
  
      my @kvlist = pairgrep { BLOCK } @kvlist;
  
      my $count = pairgrep { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<grep> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns an even-sized list of those pairs for which the C<BLOCK> returned true
  in list context, or the count of the B<number of pairs> in scalar context.
  (Note, therefore, in scalar context that it returns a number half the size of
  the count of items it would have returned in list context).
  
      @subset = pairgrep { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairgrep> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairfirst
  
      my ( $key, $val ) = pairfirst { BLOCK } @kvlist;
  
      my $found = pairfirst { BLOCK } @kvlist;
  
  I<Since version 1.30.>
  
  Similar to the L</first> function, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in scalar
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the first pair of values from the list for which the C<BLOCK> returned
  true in list context, or an empty list of no such pair was found. In scalar
  context it returns a simple boolean value, rather than either the key or the
  value found.
  
      ( $key, $value ) = pairfirst { $a =~ m/^[[:upper:]]+$/ } @kvlist
  
  As with C<grep> aliasing C<$_> to list elements, C<pairfirst> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  =head2 pairmap
  
      my @list = pairmap { BLOCK } @kvlist;
  
      my $count = pairmap { BLOCK } @kvlist;
  
  I<Since version 1.29.>
  
  Similar to perl's C<map> keyword, but interprets the given list as an
  even-sized list of pairs. It invokes the C<BLOCK> multiple times, in list
  context, with C<$a> and C<$b> set to successive pairs of values from the
  C<@kvlist>.
  
  Returns the concatenation of all the values returned by the C<BLOCK> in list
  context, or the count of the number of items that would have been returned in
  scalar context.
  
      @result = pairmap { "The key $a has value $b" } @kvlist
  
  As with C<map> aliasing C<$_> to list elements, C<pairmap> aliases C<$a> and
  C<$b> to elements of the given list. Any modifications of it by the code block
  will be visible to the caller.
  
  See L</KNOWN BUGS> for a known-bug with C<pairmap>, and a workaround.
  
  =cut
  
  =head1 OTHER FUNCTIONS
  
  =cut
  
  =head2 shuffle
  
      my @values = shuffle @values;
  
  Returns the values of the input in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =head2 uniq
  
      my @subset = uniq @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  DWIM-ish string equality or C<undef> test. Preserves the order of unique
  elements, and retains the first value of any duplicate set.
  
      my $count = uniq @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  The C<undef> value is treated by this function as distinct from the empty
  string, and no warning will be produced. It is left as-is in the returned
  list. Subsequent C<undef> values are still considered identical to the first,
  and will be removed.
  
  =head2 uniqnum
  
      my @subset = uniqnum @values
  
  I<Since version 1.44.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  numerical equality test. Preserves the order of unique elements, and retains
  the first value of any duplicate set.
  
      my $count = uniqnum @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other numerical operations treat it; it
  compares equal to zero but additionally produces a warning if such warnings
  are enabled (C<use warnings 'uninitialized';>). In addition, an C<undef> in
  the returned list is coerced into a numerical zero, so that the entire list of
  values returned by C<uniqnum> are well-behaved as numbers.
  
  Note also that multiple IEEE C<NaN> values are treated as duplicates of
  each other, regardless of any differences in their payloads, and despite
  the fact that C<< 0+'NaN' == 0+'NaN' >> yields false.
  
  =head2 uniqstr
  
      my @subset = uniqstr @values
  
  I<Since version 1.45.>
  
  Filters a list of values to remove subsequent duplicates, as judged by a
  string equality test. Preserves the order of unique elements, and retains the
  first value of any duplicate set.
  
      my $count = uniqstr @values
  
  In scalar context, returns the number of elements that would have been
  returned as a list.
  
  Note that C<undef> is treated much as other string operations treat it; it
  compares equal to the empty string but additionally produces a warning if such
  warnings are enabled (C<use warnings 'uninitialized';>). In addition, an
  C<undef> in the returned list is coerced into an empty string, so that the
  entire list of values returned by C<uniqstr> are well-behaved as strings.
  
  =cut
  
  =head1 KNOWN BUGS
  
  =head2 RT #95409
  
  L<https://rt.cpan.org/Ticket/Display.html?id=95409>
  
  If the block of code given to L</pairmap> contains lexical variables that are
  captured by a returned closure, and the closure is executed after the block
  has been re-used for the next iteration, these lexicals will not see the
  correct values. For example:
  
   my @subs = pairmap {
      my $var = "$a is $b";
      sub { print "$var\n" };
   } one => 1, two => 2, three => 3;
  
   $_->() for @subs;
  
  Will incorrectly print
  
   three is 3
   three is 3
   three is 3
  
  This is due to the performance optimisation of using C<MULTICALL> for the code
  block, which means that fresh SVs do not get allocated for each call to the
  block. Instead, the same SV is re-assigned for each iteration, and all the
  closures will share the value seen on the final iteration.
  
  To work around this bug, surround the code with a second set of braces. This
  creates an inner block that defeats the C<MULTICALL> logic, and does get fresh
  SVs allocated each time:
  
   my @subs = pairmap {
      {
         my $var = "$a is $b";
         sub { print "$var\n"; }
      }
   } one => 1, two => 2, three => 3;
  
  This bug only affects closures that are generated by the block but used
  afterwards. Lexical variables that are only used during the lifetime of the
  block's execution will take their individual values for each invocation, as
  normal.
  
  =head2 uniqnum() on oversized bignums
  
  Due to the way that C<uniqnum()> compares numbers, it cannot distinguish
  differences between bignums (especially bigints) that are too large to fit in
  the native platform types. For example,
  
   my $x = Math::BigInt->new( "1" x 100 );
   my $y = $x + 1;
  
   say for uniqnum( $x, $y );
  
  Will print just the value of C<$x>, believing that C<$y> is a numerically-
  equivalent value. This bug does not affect C<uniqstr()>, which will correctly
  observe that the two values stringify to different strings.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  Recent additions and current maintenance by
  Paul Evans, <leonerd@leonerd.org.uk>.
  
  =cut
  
  1;
X86_64-LINUX_LIST_UTIL

$fatpacked{"x86_64-linux/List/Util/XS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use warnings;
  use List::Util;
  
  our $VERSION = "1.49";       # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  Starting with release 1.23_03, Scalar-List-Util is B<always> using
  the XS implementation, but for backwards compatibility, we still
  ship the C<List::Util::XS> module which just loads C<List::Util>.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_LIST_UTIL_XS

$fatpacked{"x86_64-linux/PerlIO/utf8_strict.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_PERLIO_UTF8_STRICT';
  package PerlIO::utf8_strict;
  $PerlIO::utf8_strict::VERSION = '0.006';
  use strict;
  use warnings;
  
  use XSLoader;
  
  XSLoader::load(__PACKAGE__, __PACKAGE__->VERSION);
  
  1;
  
  #ABSTRACT: Fast and correct UTF-8 IO
  
  __END__
  
  =pod
  
  =encoding UTF-8
  
  =head1 NAME
  
  PerlIO::utf8_strict - Fast and correct UTF-8 IO
  
  =head1 VERSION
  
  version 0.006
  
  =head1 SYNOPSIS
  
   open my $fh, '<:utf8_strict', $filename;
  
  =head1 DESCRIPTION
  
  This module provides a fast and correct UTF-8 PerlIO layer. Unlike perl's default C<:utf8> layer it checks the input for correctness.
  
  =head1 LAYER ARGUMENTS
  
  =over 4
  
  =item allow_noncharacters
  
  =item allow_surrogates
  
  =back
  
  =head1 EXPORT
  
  PerlIO::utf8_strict exports no subroutines or symbols, just a perl layer C<utf8_strict>
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Can't decode ill-formed UTF-8 octet sequence <%s>
  
  (F) Encountered an ill-formed UTF-8 octet sequence. <%s> contains a hexadecimal 
  representation of the maximal subpart of the ill-formed subsequence.
  
  =item Can't interchange noncharacter code point U+%.4X
  
  (F) Noncharacters is permanently reserved for internal use and that should 
  never be interchanged. Noncharacters consist of the values U+nFFFE and U+nFFFF 
  (where n is from 0 to 10^16) and the values U+FDD0..U+FDEF.
  
  =back
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  Leon Timmermans <leont@cpan.org>
  
  =item *
  
  Christian Hansen <chansen@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Leon Timmermans, Christian Hansen.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
X86_64-LINUX_PERLIO_UTF8_STRICT

$fatpacked{"x86_64-linux/Scalar/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SCALAR_UTIL';
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # Maintained since 2013 by Paul Evans <leonerd@leonerd.org.uk>
  
  package Scalar::Util;
  
  use strict;
  use warnings;
  require Exporter;
  
  our @ISA       = qw(Exporter);
  our @EXPORT_OK = qw(
    blessed refaddr reftype weaken unweaken isweak
  
    dualvar isdual isvstring looks_like_number openhandle readonly set_prototype
    tainted
  );
  our $VERSION    = "1.49";
  $VERSION   = eval $VERSION;
  
  require List::Util; # List::Util loads the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  our @EXPORT_FAIL;
  
  unless (defined &weaken) {
    push @EXPORT_FAIL, qw(weaken);
  }
  unless (defined &isweak) {
    push @EXPORT_FAIL, qw(isweak isvstring);
  }
  unless (defined &isvstring) {
    push @EXPORT_FAIL, qw(isvstring);
  }
  
  sub export_fail {
    if (grep { /^(?:weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^isvstring$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  # set_prototype has been moved to Sub::Util with a different interface
  sub set_prototype(&$)
  {
    my ( $code, $proto ) = @_;
    return Sub::Util::set_prototype( $proto, $code );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isdual readonly refaddr reftype
                          tainted weaken isweak isvstring looks_like_number
                          set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have expressed
  would be nice to have in the perl core, but the usage would not really be high
  enough to warrant the use of a keyword, and the size would be so small that 
  being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines.
  
  =cut
  
  =head1 FUNCTIONS FOR REFERENCES
  
  The following functions all perform some useful activity on reference values.
  
  =head2 blessed
  
      my $pkg = blessed( $ref );
  
  If C<$ref> is a blessed reference, the name of the package that it is blessed
  into is returned. Otherwise C<undef> is returned.
  
      $scalar = "foo";
      $class  = blessed $scalar;           # undef
  
      $ref    = [];
      $class  = blessed $ref;              # undef
  
      $obj    = bless [], "Foo";
      $class  = blessed $obj;              # "Foo"
  
  Take care when using this function simply as a truth test (such as in
  C<if(blessed $ref)...>) because the package name C<"0"> is defined yet false.
  
  =head2 refaddr
  
      my $addr = refaddr( $ref );
  
  If C<$ref> is reference, the internal memory address of the referenced value is
  returned as a plain integer. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =head2 reftype
  
      my $type = reftype( $ref );
  
  If C<$ref> is a reference, the basic Perl type of the variable referenced is
  returned as a plain string (such as C<ARRAY> or C<HASH>). Otherwise C<undef>
  is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =head2 weaken
  
      weaken( $ref );
  
  The lvalue C<$ref> will be turned into a weak reference. This means that it
  will not hold a reference count on the object it references. Also, when the
  reference count on that object reaches zero, the reference will be set to
  undef. This function mutates the lvalue passed as its argument and returns no
  value.
  
  This is useful for keeping copies of references, but you don't want to prevent
  the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference, the copy
  will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never be
  destroyed because there is now always a strong reference to them in the @object
  array.
  
  =head2 unweaken
  
      unweaken( $ref );
  
  I<Since version 1.36.>
  
  The lvalue C<REF> will be turned from a weak reference back into a normal
  (strong) reference again. This function mutates the lvalue passed as its
  argument and returns no value. This undoes the action performed by
  L</weaken>.
  
  This function is slightly neater and more convenient than the
  otherwise-equivalent code
  
      my $tmp = $REF;
      undef $REF;
      $REF = $tmp;
  
  (because in particular, simply assigning a weak reference back to itself does
  not work to unweaken it; C<$REF = $REF> does not work).
  
  =head2 isweak
  
      my $weak = isweak( $ref );
  
  Returns true if C<$ref> is a weak reference.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =head1 OTHER FUNCTIONS
  
  =head2 dualvar
  
      my $var = dualvar( $num, $string );
  
  Returns a scalar that has the value C<$num> in a numeric context and the value
  C<$string> in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =head2 isdual
  
      my $dual = isdual( $var );
  
  I<Since version 1.26.>
  
  If C<$var> is a scalar that has both numeric and string values, the result is
  true.
  
      $foo = dualvar 86, "Nix";
      $dual = isdual($foo);               # true
  
  Note that a scalar can be made to have both string and numeric content through
  numeric operations:
  
      $foo = "10";
      $dual = isdual($foo);               # false
      $bar = $foo + 0;
      $dual = isdual($foo);               # true
  
  Note that although C<$!> appears to be a dual-valued variable, it is
  actually implemented as a magical variable inside the interpreter:
  
      $! = 1;
      print("$!\n");                      # "Operation not permitted"
      $dual = isdual($!);                 # false
  
  You can capture its numeric and string content using:
  
      $err = dualvar $!, $!;
      $dual = isdual($err);               # true
  
  =head2 isvstring
  
      my $vstring = isvstring( $var );
  
  If C<$var> is a scalar which was coded as a vstring, the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =head2 looks_like_number
  
      my $isnum = looks_like_number( $var );
  
  Returns true if perl thinks C<$var> is a number. See
  L<perlapi/looks_like_number>.
  
  =head2 openhandle
  
      my $fh = openhandle( $fh );
  
  Returns C<$fh> itself if C<$fh> may be used as a filehandle and is open, or is
  is a tied handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);           # \*STDIN
      $fh = openhandle(\*STDIN);          # \*STDIN
      $fh = openhandle(*NOTOPEN);         # undef
      $fh = openhandle("scalar");         # undef
  
  =head2 readonly
  
      my $ro = readonly( $var );
  
  Returns true if C<$var> is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =head2 set_prototype
  
      my $code = set_prototype( $code, $prototype );
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
      set_prototype \&foo, '$$';
  
  =head2 tainted
  
      my $t = tainted( $var );
  
  Return true if C<$var> is tainted.
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to
  use L</isweak> or L</weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  L</isvstring> you will need to use a newer release of perl.
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Additionally L</weaken> and L</isweak> which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  Copyright (C) 2004, 2008  Matthijs van Duin.  All rights reserved.
  Copyright (C) 2014 cPanel Inc.  All rights reserved.
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
X86_64-LINUX_SCALAR_UTIL

$fatpacked{"x86_64-linux/Sub/Util.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_SUB_UTIL';
  # Copyright (c) 2014 Paul Evans <leonerd@leonerd.org.uk>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Sub::Util;
  
  use strict;
  use warnings;
  
  require Exporter;
  
  our @ISA = qw( Exporter );
  our @EXPORT_OK = qw(
    prototype set_prototype
    subname set_subname
  );
  
  our $VERSION    = "1.49";
  $VERSION   = eval $VERSION;
  
  require List::Util; # as it has the XS
  List::Util->VERSION( $VERSION ); # Ensure we got the right XS version (RT#100863)
  
  =head1 NAME
  
  Sub::Util - A selection of utility subroutines for subs and CODE references
  
  =head1 SYNOPSIS
  
      use Sub::Util qw( prototype set_prototype subname set_subname );
  
  =head1 DESCRIPTION
  
  C<Sub::Util> contains a selection of utility subroutines that are useful for
  operating on subs and CODE references.
  
  The rationale for inclusion in this module is that the function performs some
  work for which an XS implementation is essential because it cannot be
  implemented in Pure Perl, and which is sufficiently-widely used across CPAN
  that its popularity warrants inclusion in a core module, which this is.
  
  =cut
  
  =head1 FUNCTIONS
  
  =cut
  
  =head2 prototype
  
      my $proto = prototype( $code )
  
  I<Since version 1.40.>
  
  Returns the prototype of the given C<$code> reference, if it has one, as a
  string. This is the same as the C<CORE::prototype> operator; it is included
  here simply for symmetry and completeness with the other functions.
  
  =cut
  
  sub prototype
  {
    my ( $code ) = @_;
    return CORE::prototype( $code );
  }
  
  =head2 set_prototype
  
      my $code = set_prototype $prototype, $code;
  
  I<Since version 1.40.>
  
  Sets the prototype of the function given by the C<$code> reference, or deletes
  it if C<$prototype> is C<undef>. Returns the C<$code> reference itself.
  
  I<Caution>: This function takes arguments in a different order to the previous
  copy of the code from C<Scalar::Util>. This is to match the order of
  C<set_subname>, and other potential additions in this file. This order has
  been chosen as it allows a neat and simple chaining of other
  C<Sub::Util::set_*> functions as might become available, such as:
  
   my $code =
      set_subname   name_here =>
      set_prototype '&@'      =>
      set_attribute ':lvalue' =>
         sub { ...... };
  
  =cut
  
  =head2 subname
  
      my $name = subname( $code )
  
  I<Since version 1.40.>
  
  Returns the name of the given C<$code> reference, if it has one. Normal named
  subs will give a fully-qualified name consisting of the package and the
  localname separated by C<::>. Anonymous code references will give C<__ANON__>
  as the localname. If a name has been set using L</set_subname>, this name will
  be returned instead.
  
  This function was inspired by C<sub_fullname> from L<Sub::Identify>. The
  remaining functions that C<Sub::Identify> implements can easily be emulated
  using regexp operations, such as
  
   sub get_code_info { return (subname $_[0]) =~ m/^(.+)::(.+?)$/ }
   sub sub_name      { return (get_code_info $_[0])[0] }
   sub stash_name    { return (get_code_info $_[0])[1] }
  
  I<Users of Sub::Name beware>: This function is B<not> the same as
  C<Sub::Name::subname>; it returns the existing name of the sub rather than
  changing it. To set or change a name, see instead L</set_subname>.
  
  =cut
  
  =head2 set_subname
  
      my $code = set_subname $name, $code;
  
  I<Since version 1.40.>
  
  Sets the name of the function given by the C<$code> reference. Returns the
  C<$code> reference itself. If the C<$name> is unqualified, the package of the
  caller is used to qualify it.
  
  This is useful for applying names to anonymous CODE references so that stack
  traces and similar situations, to give a useful name rather than having the
  default of C<__ANON__>. Note that this name is only used for this situation;
  the C<set_subname> will not install it into the symbol table; you will have to
  do that yourself if required.
  
  However, since the name is not used by perl except as the return value of
  C<caller>, for stack traces or similar, there is no actual requirement that
  the name be syntactically valid as a perl function name. This could be used to
  attach extra information that could be useful in debugging stack traces.
  
  This function was copied from C<Sub::Name::subname> and renamed to the naming
  convention of this module.
  
  =cut
  
  =head1 AUTHOR
  
  The general structure of this module was written by Paul Evans
  <leonerd@leonerd.org.uk>.
  
  The XS implementation of L</set_subname> was copied from L<Sub::Name> by
  Matthijs van Duin <xmath@cpan.org>
  
  =cut
  
  1;
X86_64-LINUX_SUB_UTIL

$fatpacked{"x86_64-linux/version.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION';
  #!perl -w
  package version;
  
  use 5.006002;
  use strict;
  use warnings::register;
  if ($] >= 5.015) {
      warnings::register_categories(qw/version/);
  }
  
  use vars qw(@ISA $VERSION $CLASS $STRICT $LAX *declare *qv);
  
  $VERSION = 0.9918;
  $CLASS = 'version';
  
  # !!!!Delete this next block completely when adding to Perl core!!!!
  {
      local $SIG{'__DIE__'};
      eval "use version::vxs $VERSION";
      if ( $@ ) { # don't have the XS version installed
  	eval "use version::vpp $VERSION"; # don't tempt fate
  	die "$@" if ( $@ );
  	push @ISA, "version::vpp";
  	local $^W;
  	*version::qv = \&version::vpp::qv;
  	*version::declare = \&version::vpp::declare;
  	*version::_VERSION = \&version::vpp::_VERSION;
  	*version::vcmp = \&version::vpp::vcmp;
  	*version::new = \&version::vpp::new;
  	*version::numify = \&version::vpp::numify;
  	*version::normal = \&version::vpp::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vpp::stringify;
  	    *{'version::(""'} = \&version::vpp::stringify;
  	    *{'version::(<=>'} = \&version::vpp::vcmp;
  	    *{'version::(cmp'} = \&version::vpp::vcmp;
  	    *version::parse = \&version::vpp::parse;
  	}
      }
      else { # use XS module
  	push @ISA, "version::vxs";
  	local $^W;
  	*version::declare = \&version::vxs::declare;
  	*version::qv = \&version::vxs::qv;
  	*version::_VERSION = \&version::vxs::_VERSION;
  	*version::vcmp = \&version::vxs::VCMP;
  	*version::new = \&version::vxs::new;
  	*version::numify = \&version::vxs::numify;
  	*version::normal = \&version::vxs::normal;
  	if ($] >= 5.009000) {
  	    no strict 'refs';
  	    *version::stringify = \&version::vxs::stringify;
  	    *{'version::(""'} = \&version::vxs::stringify;
  	    *{'version::(<=>'} = \&version::vxs::VCMP;
  	    *{'version::(cmp'} = \&version::vxs::VCMP;
  	    *version::parse = \&version::vxs::parse;
  	}
      }
  }
  
  # avoid using Exporter
  require version::regex;
  *version::is_lax = \&version::regex::is_lax;
  *version::is_strict = \&version::regex::is_strict;
  *LAX = \$version::regex::LAX;
  *LAX_DECIMAL_VERSION = \$version::regex::LAX_DECIMAL_VERSION;
  *LAX_DOTTED_DECIMAL_VERSION = \$version::regex::LAX_DOTTED_DECIMAL_VERSION;
  *STRICT = \$version::regex::STRICT;
  *STRICT_DECIMAL_VERSION = \$version::regex::STRICT_DECIMAL_VERSION;
  *STRICT_DOTTED_DECIMAL_VERSION = \$version::regex::STRICT_DOTTED_DECIMAL_VERSION;
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	local $^W;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  
  1;
X86_64-LINUX_VERSION

$fatpacked{"x86_64-linux/version/regex.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_REGEX';
  package version::regex;
  
  use strict;
  
  use vars qw(
      $VERSION $CLASS $STRICT $LAX
      $STRICT_DECIMAL_VERSION $STRICT_DOTTED_DECIMAL_VERSION
      $LAX_DECIMAL_VERSION $LAX_DOTTED_DECIMAL_VERSION
  );
  
  $VERSION = 0.9918;
  
  #--------------------------------------------------------------------------#
  # Version regexp components
  #--------------------------------------------------------------------------#
  
  # Fraction part of a decimal version number.  This is a common part of
  # both strict and lax decimal versions
  
  my $FRACTION_PART = qr/\.[0-9]+/;
  
  # First part of either decimal or dotted-decimal strict version number.
  # Unsigned integer with no leading zeroes (except for zero itself) to
  # avoid confusion with octal.
  
  my $STRICT_INTEGER_PART = qr/0|[1-9][0-9]*/;
  
  # First part of either decimal or dotted-decimal lax version number.
  # Unsigned integer, but allowing leading zeros.  Always interpreted
  # as decimal.  However, some forms of the resulting syntax give odd
  # results if used as ordinary Perl expressions, due to how perl treats
  # octals.  E.g.
  #   version->new("010" ) == 10
  #   version->new( 010  ) == 8
  #   version->new( 010.2) == 82  # "8" . "2"
  
  my $LAX_INTEGER_PART = qr/[0-9]+/;
  
  # Second and subsequent part of a strict dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.
  # Limited to three digits to avoid overflow when converting to decimal
  # form and also avoid problematic style with excessive leading zeroes.
  
  my $STRICT_DOTTED_DECIMAL_PART = qr/\.[0-9]{1,3}/;
  
  # Second and subsequent part of a lax dotted-decimal version number.
  # Leading zeroes are permitted, and the number is always decimal.  No
  # limit on the numerical value or number of digits, so there is the
  # possibility of overflow when converting to decimal form.
  
  my $LAX_DOTTED_DECIMAL_PART = qr/\.[0-9]+/;
  
  # Alpha suffix part of lax version number syntax.  Acts like a
  # dotted-decimal part.
  
  my $LAX_ALPHA_PART = qr/_[0-9]+/;
  
  #--------------------------------------------------------------------------#
  # Strict version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Strict decimal version number.
  
  $STRICT_DECIMAL_VERSION =
      qr/ $STRICT_INTEGER_PART $FRACTION_PART? /x;
  
  # Strict dotted-decimal version number.  Must have both leading "v" and
  # at least three parts, to avoid confusion with decimal syntax.
  
  $STRICT_DOTTED_DECIMAL_VERSION =
      qr/ v $STRICT_INTEGER_PART $STRICT_DOTTED_DECIMAL_PART{2,} /x;
  
  # Complete strict version number syntax -- should generally be used
  # anchored: qr/ \A $STRICT \z /x
  
  $STRICT =
      qr/ $STRICT_DECIMAL_VERSION | $STRICT_DOTTED_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  # Lax version regexp definitions
  #--------------------------------------------------------------------------#
  
  # Lax decimal version number.  Just like the strict one except for
  # allowing an alpha suffix or allowing a leading or trailing
  # decimal-point
  
  $LAX_DECIMAL_VERSION =
      qr/ $LAX_INTEGER_PART (?: $FRACTION_PART | \. )? $LAX_ALPHA_PART?
  	|
  	$FRACTION_PART $LAX_ALPHA_PART?
      /x;
  
  # Lax dotted-decimal version number.  Distinguished by having either
  # leading "v" or at least three non-alpha parts.  Alpha part is only
  # permitted if there are at least two non-alpha parts. Strangely
  # enough, without the leading "v", Perl takes .1.2 to mean v0.1.2,
  # so when there is no "v", the leading part is optional
  
  $LAX_DOTTED_DECIMAL_VERSION =
      qr/
  	v $LAX_INTEGER_PART (?: $LAX_DOTTED_DECIMAL_PART+ $LAX_ALPHA_PART? )?
  	|
  	$LAX_INTEGER_PART? $LAX_DOTTED_DECIMAL_PART{2,} $LAX_ALPHA_PART?
      /x;
  
  # Complete lax version number syntax -- should generally be used
  # anchored: qr/ \A $LAX \z /x
  #
  # The string 'undef' is a special case to make for easier handling
  # of return values from ExtUtils::MM->parse_version
  
  $LAX =
      qr/ undef | $LAX_DOTTED_DECIMAL_VERSION | $LAX_DECIMAL_VERSION /x;
  
  #--------------------------------------------------------------------------#
  
  # Preloaded methods go here.
  sub is_strict	{ defined $_[0] && $_[0] =~ qr/ \A $STRICT \z /x }
  sub is_lax	{ defined $_[0] && $_[0] =~ qr/ \A $LAX \z /x }
  
  1;
X86_64-LINUX_VERSION_REGEX

$fatpacked{"x86_64-linux/version/vpp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VPP';
  package charstar;
  # a little helper class to emulate C char* semantics in Perl
  # so that prescan_version can use the same code as in C
  
  use overload (
      '""'	=> \&thischar,
      '0+'	=> \&thischar,
      '++'	=> \&increment,
      '--'	=> \&decrement,
      '+'		=> \&plus,
      '-'		=> \&minus,
      '*'		=> \&multiply,
      'cmp'	=> \&cmp,
      '<=>'	=> \&spaceship,
      'bool'	=> \&thischar,
      '='		=> \&clone,
  );
  
  sub new {
      my ($self, $string) = @_;
      my $class = ref($self) || $self;
  
      my $obj = {
  	string  => [split(//,$string)],
  	current => 0,
      };
      return bless $obj, $class;
  }
  
  sub thischar {
      my ($self) = @_;
      my $last = $#{$self->{string}};
      my $curr = $self->{current};
      if ($curr >= 0 && $curr <= $last) {
  	return $self->{string}->[$curr];
      }
      else {
  	return '';
      }
  }
  
  sub increment {
      my ($self) = @_;
      $self->{current}++;
  }
  
  sub decrement {
      my ($self) = @_;
      $self->{current}--;
  }
  
  sub plus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} += $offset;
      return $rself;
  }
  
  sub minus {
      my ($self, $offset) = @_;
      my $rself = $self->clone;
      $rself->{current} -= $offset;
      return $rself;
  }
  
  sub multiply {
      my ($left, $right, $swapped) = @_;
      my $char = $left->thischar();
      return $char * $right;
  }
  
  sub spaceship {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	$right = $left->new($right);
      }
      return $left->{current} <=> $right->{current};
  }
  
  sub cmp {
      my ($left, $right, $swapped) = @_;
      unless (ref($right)) { # not an object already
  	if (length($right) == 1) { # comparing single character only
  	    return $left->thischar cmp $right;
  	}
  	$right = $left->new($right);
      }
      return $left->currstr cmp $right->currstr;
  }
  
  sub bool {
      my ($self) = @_;
      my $char = $self->thischar;
      return ($char ne '');
  }
  
  sub clone {
      my ($left, $right, $swapped) = @_;
      $right = {
  	string  => [@{$left->{string}}],
  	current => $left->{current},
      };
      return bless $right, ref($left);
  }
  
  sub currstr {
      my ($self, $s) = @_;
      my $curr = $self->{current};
      my $last = $#{$self->{string}};
      if (defined($s) && $s->{current} < $last) {
  	$last = $s->{current};
      }
  
      my $string = join('', @{$self->{string}}[$curr..$last]);
      return $string;
  }
  
  package version::vpp;
  
  use 5.006002;
  use strict;
  use warnings::register;
  
  use Config;
  use vars qw($VERSION $CLASS @ISA $LAX $STRICT $WARN_CATEGORY);
  $VERSION = 0.9918;
  $CLASS = 'version::vpp';
  if ($] > 5.015) {
      warnings::register_categories(qw/version/);
      $WARN_CATEGORY = 'version';
  } else {
      $WARN_CATEGORY = 'numeric';
  }
  
  require version::regex;
  *version::vpp::is_strict = \&version::regex::is_strict;
  *version::vpp::is_lax = \&version::regex::is_lax;
  *LAX = \$version::regex::LAX;
  *STRICT = \$version::regex::STRICT;
  
  use overload (
      '""'       => \&stringify,
      '0+'       => \&numify,
      'cmp'      => \&vcmp,
      '<=>'      => \&vcmp,
      'bool'     => \&vbool,
      '+'        => \&vnoop,
      '-'        => \&vnoop,
      '*'        => \&vnoop,
      '/'        => \&vnoop,
      '+='        => \&vnoop,
      '-='        => \&vnoop,
      '*='        => \&vnoop,
      '/='        => \&vnoop,
      'abs'      => \&vnoop,
  );
  
  sub import {
      no strict 'refs';
      my ($class) = shift;
  
      # Set up any derived class
      unless ($class eq $CLASS) {
  	local $^W;
  	*{$class.'::declare'} =  \&{$CLASS.'::declare'};
  	*{$class.'::qv'} = \&{$CLASS.'::qv'};
      }
  
      my %args;
      if (@_) { # any remaining terms are arguments
  	map { $args{$_} = 1 } @_
      }
      else { # no parameters at all on use line
  	%args =
  	(
  	    qv => 1,
  	    'UNIVERSAL::VERSION' => 1,
  	);
      }
  
      my $callpkg = caller();
  
      if (exists($args{declare})) {
  	*{$callpkg.'::declare'} =
  	    sub {return $class->declare(shift) }
  	  unless defined(&{$callpkg.'::declare'});
      }
  
      if (exists($args{qv})) {
  	*{$callpkg.'::qv'} =
  	    sub {return $class->qv(shift) }
  	  unless defined(&{$callpkg.'::qv'});
      }
  
      if (exists($args{'UNIVERSAL::VERSION'})) {
  	no warnings qw/redefine/;
  	*UNIVERSAL::VERSION
  		= \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'VERSION'})) {
  	*{$callpkg.'::VERSION'} = \&{$CLASS.'::_VERSION'};
      }
  
      if (exists($args{'is_strict'})) {
  	*{$callpkg.'::is_strict'} = \&{$CLASS.'::is_strict'}
  	  unless defined(&{$callpkg.'::is_strict'});
      }
  
      if (exists($args{'is_lax'})) {
  	*{$callpkg.'::is_lax'} = \&{$CLASS.'::is_lax'}
  	  unless defined(&{$callpkg.'::is_lax'});
      }
  }
  
  my $VERSION_MAX = 0x7FFFFFFF;
  
  # implement prescan_version as closely to the C version as possible
  use constant TRUE  => 1;
  use constant FALSE => 0;
  
  sub isDIGIT {
      my ($char) = shift->thischar();
      return ($char =~ /\d/);
  }
  
  sub isALPHA {
      my ($char) = shift->thischar();
      return ($char =~ /[a-zA-Z]/);
  }
  
  sub isSPACE {
      my ($char) = shift->thischar();
      return ($char =~ /\s/);
  }
  
  sub BADVERSION {
      my ($s, $errstr, $error) = @_;
      if ($errstr) {
  	$$errstr = $error;
      }
      return $s;
  }
  
  sub prescan_version {
      my ($s, $strict, $errstr, $sqv, $ssaw_decimal, $swidth, $salpha) = @_;
      my $qv          = defined $sqv          ? $$sqv          : FALSE;
      my $saw_decimal = defined $ssaw_decimal ? $$ssaw_decimal : 0;
      my $width       = defined $swidth       ? $$swidth       : 3;
      my $alpha       = defined $salpha       ? $$salpha       : FALSE;
  
      my $d = $s;
  
      if ($qv && isDIGIT($d)) {
  	goto dotted_decimal_version;
      }
  
      if ($d eq 'v') { # explicit v-string
  	$d++;
  	if (isDIGIT($d)) {
  	    $qv = TRUE;
  	}
  	else { # degenerate v-string
  	    # requires v1.2.3
  	    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	}
  
  dotted_decimal_version:
  	if ($strict && $d eq '0' && isDIGIT($d+1)) {
  	    # no leading zeros allowed
  	    return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	}
  
  	while (isDIGIT($d)) { 	# integer part
  	    $d++;
  	}
  
  	if ($d eq '.')
  	{
  	    $saw_decimal++;
  	    $d++; 		# decimal point
  	}
  	else
  	{
  	    if ($strict) {
  		# require v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	    else {
  		goto version_prescan_finish;
  	    }
  	}
  
  	{
  	    my $i = 0;
  	    my $j = 0;
  	    while (isDIGIT($d)) {	# just keep reading
  		$i++;
  		while (isDIGIT($d)) {
  		    $d++; $j++;
  		    # maximum 3 digits between decimal
  		    if ($strict && $j > 3) {
  			return BADVERSION($s,$errstr,"Invalid version format (maximum 3 digits between decimals)");
  		    }
  		}
  		if ($d eq '_') {
  		    if ($strict) {
  			return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		    }
  		    if ( $alpha ) {
  			return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		    }
  		    $d++;
  		    $alpha = TRUE;
  		}
  		elsif ($d eq '.') {
  		    if ($alpha) {
  			return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		    }
  		    $saw_decimal++;
  		    $d++;
  		}
  		elsif (!isDIGIT($d)) {
  		    last;
  		}
  		$j = 0;
  	    }
  
  	    if ($strict && $i < 2) {
  		# requires v1.2.3
  		return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions require at least three parts)");
  	    }
  	}
      } 					# end if dotted-decimal
      else
      {					# decimal versions
  	my $j = 0;
  	# special $strict case for leading '.' or '0'
  	if ($strict) {
  	    if ($d eq '.') {
  		return BADVERSION($s,$errstr,"Invalid version format (0 before decimal required)");
  	    }
  	    if ($d eq '0' && isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (no leading zeros)");
  	    }
  	}
  
  	# and we never support negative version numbers
  	if ($d eq '-') {
  	    return BADVERSION($s,$errstr,"Invalid version format (negative version number)");
  	}
  
  	# consume all of the integer part
  	while (isDIGIT($d)) {
  	    $d++;
  	}
  
  	# look for a fractional part
  	if ($d eq '.') {
  	    # we found it, so consume it
  	    $saw_decimal++;
  	    $d++;
  	}
  	elsif (!$d || $d eq ';' || isSPACE($d) || $d eq '}') {
  	    if ( $d == $s ) {
  		# found nothing
  		return BADVERSION($s,$errstr,"Invalid version format (version required)");
  	    }
  	    # found just an integer
  	    goto version_prescan_finish;
  	}
  	elsif ( $d == $s ) {
  	    # didn't find either integer or period
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  	elsif ($d eq '_') {
  	    # underscore can't come after integer part
  	    if ($strict) {
  		return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  	    }
  	    elsif (isDIGIT($d+1)) {
  		return BADVERSION($s,$errstr,"Invalid version format (alpha without decimal)");
  	    }
  	    else {
  		return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  	    }
  	}
  	elsif ($d) {
  	    # anything else after integer part is just invalid data
  	    return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
  	}
  
  	# scan the fractional part after the decimal point
  	if ($d && !isDIGIT($d) && ($strict || ! ($d eq ';' || isSPACE($d) || $d eq '}') )) {
  		# $strict or lax-but-not-the-end
  		return BADVERSION($s,$errstr,"Invalid version format (fractional part required)");
  	}
  
  	while (isDIGIT($d)) {
  	    $d++; $j++;
  	    if ($d eq '.' && isDIGIT($d-1)) {
  		if ($alpha) {
  		    return BADVERSION($s,$errstr,"Invalid version format (underscores before decimal)");
  		}
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (dotted-decimal versions must begin with 'v')");
  		}
  		$d = $s; # start all over again
  		$qv = TRUE;
  		goto dotted_decimal_version;
  	    }
  	    if ($d eq '_') {
  		if ($strict) {
  		    return BADVERSION($s,$errstr,"Invalid version format (no underscores)");
  		}
  		if ( $alpha ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (multiple underscores)");
  		}
  		if ( ! isDIGIT($d+1) ) {
  		    return BADVERSION($s,$errstr,"Invalid version format (misplaced underscore)");
  		}
  		$width = $j;
  		$d++;
  		$alpha = TRUE;
  	    }
  	}
      }
  
  version_prescan_finish:
      while (isSPACE($d)) {
  	$d++;
      }
  
      if ($d && !isDIGIT($d) && (! ($d eq ';' || $d eq '}') )) {
  	# trailing non-numeric data
  	return BADVERSION($s,$errstr,"Invalid version format (non-numeric data)");
      }
      if ($saw_decimal > 1 && ($d-1) eq '.') {
  	# no trailing period allowed
  	return BADVERSION($s,$errstr,"Invalid version format (trailing decimal)");
      }
  
      if (defined $sqv) {
  	$$sqv = $qv;
      }
      if (defined $swidth) {
  	$$swidth = $width;
      }
      if (defined $ssaw_decimal) {
  	$$ssaw_decimal = $saw_decimal;
      }
      if (defined $salpha) {
  	$$salpha = $alpha;
      }
      return $d;
  }
  
  sub scan_version {
      my ($s, $rv, $qv) = @_;
      my $start;
      my $pos;
      my $last;
      my $errstr;
      my $saw_decimal = 0;
      my $width = 3;
      my $alpha = FALSE;
      my $vinf = FALSE;
      my @av;
  
      $s = new charstar $s;
  
      while (isSPACE($s)) { # leading whitespace is OK
  	$s++;
      }
  
      $last = prescan_version($s, FALSE, \$errstr, \$qv, \$saw_decimal,
  	\$width, \$alpha);
  
      if ($errstr) {
  	# 'undef' is a special case and not an error
  	if ( $s ne 'undef') {
  	    require Carp;
  	    Carp::croak($errstr);
  	}
      }
  
      $start = $s;
      if ($s eq 'v') {
  	$s++;
      }
      $pos = $s;
  
      if ( $qv ) {
  	$$rv->{qv} = $qv;
      }
      if ( $alpha ) {
  	$$rv->{alpha} = $alpha;
      }
      if ( !$qv && $width < 3 ) {
  	$$rv->{width} = $width;
      }
  
      while (isDIGIT($pos) || $pos eq '_') {
  	$pos++;
      }
      if (!isALPHA($pos)) {
  	my $rev;
  
  	for (;;) {
  	    $rev = 0;
  	    {
    		# this is atoi() that delimits on underscores
    		my $end = $pos;
    		my $mult = 1;
  		my $orev;
  
  		#  the following if() will only be true after the decimal
  		#  point of a version originally created with a bare
  		#  floating point number, i.e. not quoted in any way
  		#
   		if ( !$qv && $s > $start && $saw_decimal == 1 ) {
  		    $mult *= 100;
   		    while ( $s < $end ) {
  			next if $s eq '_';
  			$orev = $rev;
   			$rev += $s * $mult;
   			$mult /= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version %d",
  					   $VERSION_MAX);
  			    $s = $end - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   			$s++;
  			if ( $s eq '_' ) {
  			    $s++;
  			}
   		    }
    		}
   		else {
   		    while (--$end >= $s) {
  			next if $end eq '_';
  			$orev = $rev;
   			$rev += $end * $mult;
   			$mult *= 10;
  			if (   (abs($orev) > abs($rev))
  			    || (abs($rev) > $VERSION_MAX )) {
  			    warn("Integer overflow in version");
  			    $end = $s - 1;
  			    $rev = $VERSION_MAX;
  			    $vinf = 1;
  			}
   		    }
   		}
    	    }
  
    	    # Append revision
  	    push @av, $rev;
  	    if ( $vinf ) {
  		$s = $last;
  		last;
  	    }
  	    elsif ( $pos eq '.' ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq '_' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( $pos eq ',' && isDIGIT($pos+1) ) {
  		$s = ++$pos;
  	    }
  	    elsif ( isDIGIT($pos) ) {
  		$s = $pos;
  	    }
  	    else {
  		$s = $pos;
  		last;
  	    }
  	    if ( $qv ) {
  		while ( isDIGIT($pos) || $pos eq '_') {
  		    $pos++;
  		}
  	    }
  	    else {
  		my $digits = 0;
  		while ( ( isDIGIT($pos) || $pos eq '_' ) && $digits < 3 ) {
  		    if ( $pos ne '_' ) {
  			$digits++;
  		    }
  		    $pos++;
  		}
  	    }
  	}
      }
      if ( $qv ) { # quoted versions always get at least three terms
  	my $len = $#av;
  	#  This for loop appears to trigger a compiler bug on OS X, as it
  	#  loops infinitely. Yes, len is negative. No, it makes no sense.
  	#  Compiler in question is:
  	#  gcc version 3.3 20030304 (Apple Computer, Inc. build 1640)
  	#  for ( len = 2 - len; len > 0; len-- )
  	#  av_push(MUTABLE_AV(sv), newSViv(0));
  	#
  	$len = 2 - $len;
  	while ($len-- > 0) {
  	    push @av, 0;
  	}
      }
  
      # need to save off the current version string for later
      if ( $vinf ) {
  	$$rv->{original} = "v.Inf";
  	$$rv->{vinf} = 1;
      }
      elsif ( $s > $start ) {
  	$$rv->{original} = $start->currstr($s);
  	if ( $qv && $saw_decimal == 1 && $start ne 'v' ) {
  	    # need to insert a v to be consistent
  	    $$rv->{original} = 'v' . $$rv->{original};
  	}
      }
      else {
  	$$rv->{original} = '0';
  	push(@av, 0);
      }
  
      # And finally, store the AV in the hash
      $$rv->{version} = \@av;
  
      # fix RT#19517 - special case 'undef' as string
      if ($s eq 'undef') {
  	$s += 5;
      }
  
      return $s;
  }
  
  sub new {
      my $class = shift;
      unless (defined $class or $#_ > 1) {
  	require Carp;
  	Carp::croak('Usage: version::new(class, version)');
      }
  
      my $self = bless ({}, ref ($class) || $class);
      my $qv = FALSE;
  
      if ( $#_ == 1 ) { # must be CVS-style
  	$qv = TRUE;
      }
      my $value = pop; # always going to be the last element
  
      if ( ref($value) && eval('$value->isa("version")') ) {
  	# Can copy the elements directly
  	$self->{version} = [ @{$value->{version} } ];
  	$self->{qv} = 1 if $value->{qv};
  	$self->{alpha} = 1 if $value->{alpha};
  	$self->{original} = ''.$value->{original};
  	return $self;
      }
  
      if ( not defined $value or $value =~ /^undef$/ ) {
  	# RT #19517 - special case for undef comparison
  	# or someone forgot to pass a value
  	push @{$self->{version}}, 0;
  	$self->{original} = "0";
  	return ($self);
      }
  
  
      if (ref($value) =~ m/ARRAY|HASH/) {
  	require Carp;
  	Carp::croak("Invalid version format (non-numeric data)");
      }
  
      $value = _un_vstring($value);
  
      if ($Config{d_setlocale}) {
  	use POSIX qw/locale_h/;
  	use if $Config{d_setlocale}, 'locale';
  	my $currlocale = setlocale(LC_ALL);
  
  	# if the current locale uses commas for decimal points, we
  	# just replace commas with decimal places, rather than changing
  	# locales
  	if ( localeconv()->{decimal_point} eq ',' ) {
  	    $value =~ tr/,/./;
  	}
      }
  
      # exponential notation
      if ( $value =~ /\d+.?\d*e[-+]?\d+/ ) {
  	$value = sprintf("%.9f",$value);
  	$value =~ s/(0+)$//; # trim trailing zeros
      }
  
      my $s = scan_version($value, \$self, $qv);
  
      if ($s) { # must be something left over
  	warn(sprintf "Version string '%s' contains invalid data; "
  		   ."ignoring: '%s'", $value, $s);
      }
  
      return ($self);
  }
  
  *parse = \&new;
  
  sub numify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      my $alpha = $self->{alpha} || "";
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("%d.", $digit );
  
      if ($alpha and warnings::enabled()) {
  	warnings::warn($WARN_CATEGORY, 'alpha->numify() is lossy');
      }
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf("%03d", $digit);
      }
  
      if ( $len == 0 ) {
  	$string .= sprintf("000");
      }
  
      return $string;
  }
  
  sub normal {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
  
      my $len = $#{$self->{version}};
      my $digit = $self->{version}[0];
      my $string = sprintf("v%d", $digit );
  
      for ( my $i = 1 ; $i <= $len ; $i++ ) {
  	$digit = $self->{version}[$i];
  	$string .= sprintf(".%d", $digit);
      }
  
      if ( $len <= 2 ) {
  	for ( $len = 2 - $len; $len != 0; $len-- ) {
  	    $string .= sprintf(".%0d", 0);
  	}
      }
  
      return $string;
  }
  
  sub stringify {
      my ($self) = @_;
      unless (_verify($self)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      return exists $self->{original}
      	? $self->{original}
  	: exists $self->{qv}
  	    ? $self->normal
  	    : $self->numify;
  }
  
  sub vcmp {
      my ($left,$right,$swap) = @_;
      my $class = ref($left);
      unless ( UNIVERSAL::isa($right, $class) ) {
  	$right = $class->new($right);
      }
  
      if ( $swap ) {
  	($left, $right) = ($right, $left);
      }
      unless (_verify($left)) {
  	require Carp;
  	Carp::croak("Invalid version object");
      }
      unless (_verify($right)) {
  	require Carp;
  	Carp::croak("Invalid version format");
      }
      my $l = $#{$left->{version}};
      my $r = $#{$right->{version}};
      my $m = $l < $r ? $l : $r;
      my $lalpha = $left->is_alpha;
      my $ralpha = $right->is_alpha;
      my $retval = 0;
      my $i = 0;
      while ( $i <= $m && $retval == 0 ) {
  	$retval = $left->{version}[$i] <=> $right->{version}[$i];
  	$i++;
      }
  
      # possible match except for trailing 0's
      if ( $retval == 0 && $l != $r ) {
  	if ( $l < $r ) {
  	    while ( $i <= $r && $retval == 0 ) {
  		if ( $right->{version}[$i] != 0 ) {
  		    $retval = -1; # not a match after all
  		}
  		$i++;
  	    }
  	}
  	else {
  	    while ( $i <= $l && $retval == 0 ) {
  		if ( $left->{version}[$i] != 0 ) {
  		    $retval = +1; # not a match after all
  		}
  		$i++;
  	    }
  	}
      }
  
      return $retval;
  }
  
  sub vbool {
      my ($self) = @_;
      return vcmp($self,$self->new("0"),1);
  }
  
  sub vnoop {
      require Carp;
      Carp::croak("operation not supported with version object");
  }
  
  sub is_alpha {
      my ($self) = @_;
      return (exists $self->{alpha});
  }
  
  sub qv {
      my $value = shift;
      my $class = $CLASS;
      if (@_) {
  	$class = ref($value) || $value;
  	$value = shift;
      }
  
      $value = _un_vstring($value);
      $value = 'v'.$value unless $value =~ /(^v|\d+\.\d+\.\d)/;
      my $obj = $CLASS->new($value);
      return bless $obj, $class;
  }
  
  *declare = \&qv;
  
  sub is_qv {
      my ($self) = @_;
      return (exists $self->{qv});
  }
  
  
  sub _verify {
      my ($self) = @_;
      if ( ref($self)
  	&& eval { exists $self->{version} }
  	&& ref($self->{version}) eq 'ARRAY'
  	) {
  	return 1;
      }
      else {
  	return 0;
      }
  }
  
  sub _is_non_alphanumeric {
      my $s = shift;
      $s = new charstar $s;
      while ($s) {
  	return 0 if isSPACE($s); # early out
  	return 1 unless (isALPHA($s) || isDIGIT($s) || $s =~ /[.-]/);
  	$s++;
      }
      return 0;
  }
  
  sub _un_vstring {
      my $value = shift;
      # may be a v-string
      if ( length($value) >= 1 && $value !~ /[,._]/
  	&& _is_non_alphanumeric($value)) {
  	my $tvalue;
  	if ( $] >= 5.008_001 ) {
  	    $tvalue = _find_magic_vstring($value);
  	    $value = $tvalue if length $tvalue;
  	}
  	elsif ( $] >= 5.006_000 ) {
  	    $tvalue = sprintf("v%vd",$value);
  	    if ( $tvalue =~ /^v\d+(\.\d+)*$/ ) {
  		# must be a v-string
  		$value = $tvalue;
  	    }
  	}
      }
      return $value;
  }
  
  sub _find_magic_vstring {
      my $value = shift;
      my $tvalue = '';
      require B;
      my $sv = B::svref_2object(\$value);
      my $magic = ref($sv) eq 'B::PVMG' ? $sv->MAGIC : undef;
      while ( $magic ) {
  	if ( $magic->TYPE eq 'V' ) {
  	    $tvalue = $magic->PTR;
  	    $tvalue =~ s/^v?(.+)$/v$1/;
  	    last;
  	}
  	else {
  	    $magic = $magic->MOREMAGIC;
  	}
      }
      $tvalue =~ tr/_//d;
      return $tvalue;
  }
  
  sub _VERSION {
      my ($obj, $req) = @_;
      my $class = ref($obj) || $obj;
  
      no strict 'refs';
      if ( exists $INC{"$class.pm"} and not %{"$class\::"} and $] >= 5.008) {
  	 # file but no package
  	require Carp;
  	Carp::croak( "$class defines neither package nor VERSION"
  	    ."--version check failed");
      }
  
      my $version = eval "\$$class\::VERSION";
      if ( defined $version ) {
  	local $^W if $] <= 5.008;
  	$version = version::vpp->new($version);
      }
  
      if ( defined $req ) {
  	unless ( defined $version ) {
  	    require Carp;
  	    my $msg =  $] < 5.006
  	    ? "$class version $req required--this is only version "
  	    : "$class does not define \$$class\::VERSION"
  	      ."--version check failed";
  
  	    if ( $ENV{VERSION_DEBUG} ) {
  		Carp::confess($msg);
  	    }
  	    else {
  		Carp::croak($msg);
  	    }
  	}
  
  	$req = version::vpp->new($req);
  
  	if ( $req > $version ) {
  	    require Carp;
  	    if ( $req->is_qv ) {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->normal, $version->normal)
  		);
  	    }
  	    else {
  		Carp::croak(
  		    sprintf ("%s version %s required--".
  			"this is only version %s", $class,
  			$req->stringify, $version->stringify)
  		);
  	    }
  	}
      }
  
      return defined $version ? $version->stringify : undef;
  }
  
  1; #this line is important and will help the module return a true value
X86_64-LINUX_VERSION_VPP

$fatpacked{"x86_64-linux/version/vxs.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'X86_64-LINUX_VERSION_VXS';
  #!perl -w
  package version::vxs;
  
  use v5.10;
  use strict;
  
  use vars qw(@ISA $VERSION $CLASS );
  $VERSION = 0.9918;
  $CLASS = 'version::vxs';
  
  eval {
      require XSLoader;
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      XSLoader::load('version::vxs', $VERSION);
      1;
  } or do {
      require DynaLoader;
      push @ISA, 'DynaLoader'; 
      local $^W; # shut up the 'redefined' warning for UNIVERSAL::VERSION
      bootstrap version::vxs $VERSION;
  };
  
  # Preloaded methods go here.
  
  1;
X86_64-LINUX_VERSION_VXS

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;
use v5.14;

use Git;
use GitHub::Actions;

use File::Slurper qw(read_text);
use YAML qw(LoadFile);

use lib "lib";

use Utility;

my $fase = $ENV{'objetivo'};
my $config_file = $ENV{'CONFIGFILE'};
metadatos( $fase );

# Previa
my $student_repo = Git->repository ( Directory => "." );

# Algunas variables
my @repo_files = $student_repo->command("ls-files");

if ( -f "DOCKER_USER" ) {
  say " Usuario de Docker alternativo";
  open( my $fh, "<", "DOCKER_USER" ) || die "No puedo abrir DOCKER_USER";
  my $docker_user = <$fh>;
  chomp $docker_user;
  set_output( 'docker_user', $docker_user );
  set_env( 'docker_user', $docker_user );
} else {
  set_output( 'docker_user', $ENV{'user'} );
  set_env( 'docker_user', $ENV{'user'} );
}

objetivo_0(@repo_files);

exit_action() if $fase <= 1;

# Fase 2
my ($readme_file) = grep( /^README/, @repo_files );
my $README =  read_text( $readme_file );
my $iv;

my $file = "$config_file.yaml";
file_present( $file, \@repo_files, "Fichero metadatos" );
eval { $iv = LoadFile($file); };
if ($@) {
  set_failed( sorry( "Hay algn problema leyendo $file  $@" ) );
} else {
  say all_good( "Fichero de configuracin  $file encontrado" );
}

objetivo_1( $iv, \@repo_files );

exit_action() if $fase < 3;

objetivo_3( $iv, $README, \@repo_files );

exit_action() if $fase < 4;

objetivo_4( $iv, $README, \@repo_files );

exit_action() if $fase < 5;

objetivo_5( $iv,  \@repo_files );

exit_action() if $fase < 6;

objetivo_6( $iv,  \@repo_files );

exit_action() if $fase < 7;

objetivo_7( $iv,  \@repo_files );

exit_action() if $fase < 8;

objetivo_8( $iv);

exit_action();

# Mensajes diversos
sub metadatos {
  my $fase = shift;
  doing( "Metadatos");
  say "Fase $fase";
  end_group();
}

# Objetivos
sub objetivo_0 {
  my @repo_files = @_;
  doing( " Objetivo 0" );
  for my $f (qw( README.md .gitignore LICENSE )) {
    if ( grep( /$f/, @repo_files) )  {
      say all_good( " $f presente" );
    } else {
      error( sorry( "Falta $f" ) );
    }
  }
  end_group();
}

sub objetivo_1 {
  doing( " Objetivo 1" );
  my $iv = shift;
  for my $k (qw(lenguaje entidad)) {
    comprueba( $iv->{$k},
               " $k est presente en $config_file.yaml",
               " $k no est presente en $config_file.yaml"
             );
  }
  comprueba_caps( $iv->{'entidad'} );
  if ($iv->{'entidad'}) {
    my $repo_files = shift;
    file_present( $iv->{'entidad'}, $repo_files, "Con la entidad" );
  }
  end_group();
}

sub objetivo_3 {
  doing( " Objetivo 3" );
  my $iv = shift;
  my $README = shift;
  my $repo_files = shift;

  comprueba( $iv->{'automatizar'}, " automatizar presente", "Falta clave automatizar" );
  comprueba( ref $iv->{'automatizar'} eq "HASH",
             " automatizar es un diccionario",
             "La clave automatizar no contiene un diccionario, sino un " . ref $iv->{'automatizar'} );
  comprueba( $iv->{'automatizar'}{'fichero'}, "  automatizarfichero presente", "Falta clave automatizarfichero" );
  file_present( $iv->{'automatizar'}{'fichero'}, $repo_files, "Con el fichero de tareas" );
  comprueba( $iv->{'automatizar'}{'orden'}, " automatizarorden presente", "Falta clave automatizarorden" );
  README_contiene( "$iv->{'automatizar'}{'orden'} check", $README );
  set_output( 'ORDEN', $iv->{'automatizar'}{'orden'} );
  set_env( 'ORDEN', $iv->{'automatizar'}{'orden'} );
  end_group();
}

sub objetivo_4 {
  doing( " Objetivo 4" );
  my $iv = shift;
  my $README = shift;
  my $repo_files = shift;

  clave_presente( 'test' );
  file_present( $iv->{'test'}, $repo_files, "Con un fichero de test" );
  comprueba_caps( $iv->{'test'} );
  README_contiene( "$iv->{'automatizar'}{'orden'} test", $README );
  end_group();
}

sub objetivo_5 {
  doing( " Objetivo 5" );
  my $iv = shift;
  my $repo_files = shift;
  file_present( 'Dockerfile', $repo_files, "Dockerfile" );
  end_group();
}

sub objetivo_6 {
  doing( " Objetivo 6" );
  my $iv = shift;
  my $repo_files = shift;
  clave_presente( 'CI' );
  file_present( $iv->{'CI'}, $repo_files, "Configuracin CI" ) if $iv->{'CI'};
  comprueba_caps( $iv->{'CI'} );
  end_group();
}

sub objetivo_7 {
  doing( " Objetivo 7" );
  my $iv = shift;
  my $repo_files = shift;
  clave_presente( 'configuracion' );
  file_present( $iv->{'configuracion'}, $repo_files, "Configuracin app" ) if $iv->{'configuracion'};
  my $gitignore =  read_text( ".gitignore" );
   if ( index( $gitignore, ".env" ) >= 0 ) {
    say all_good( ".gitignore evita los .env");
  } else {
    error (sorry( "  .gitignore no evita los ficheros de configuracin " ));
  }

  end_group();
}

sub objetivo_8 {
  doing( " Objetivo 8" );
  my $iv = shift;
  clave_presente( 'framework' );
  if ( $iv->{'framework'} !~ /(express|flask)/ ) {
    say all_good( "No has elegido ninguno de los frameworks malditos");
  } else {
    error (sorry( " Te has pensado bien lo de elegir ".$iv->{'framework'}." como framework? " ));
  }

  end_group();
}

# Funciones de utilidad
sub comprueba {
  my ( $expresion, $bien, $mal ) = @_;
  if ( $expresion ) {
    say all_good($bien);
  } else {
    error( sorry( $mal ) );
  }
}

sub comprueba_caps {
  my $nombre_fichero = shift;
  my @files = (ref($nombre_fichero) eq 'ARRAY')?@$nombre_fichero:($nombre_fichero);
  for my $file (@files) {
    if ( $file =~ /[A-Z]/ ) {
      error (sorry( " $file tiene maysculas, no una buena prctica en repos " ));
    }
  }
}

sub file_present {
  my ($file, $ls_files_ref, $name ) = @_;
  say all_good("Comprobando $file");
  my @files = (ref($file) eq 'ARRAY')?@$file:($file);
  say all_good("Buscando @files en @$ls_files_ref");
  for my $a_file (@files ) {
    comprueba( grep( /$a_file/, @$ls_files_ref ),
               "Fichero $name  $a_file presente",
               "Fichero $name  $a_file no est presente" );
  }

}

sub README_contiene {
  my ($cadena, $README) = @_;
  if ( index( $README, $cadena ) >= 0 ) {
    say all_good( "El README contiene $cadena");
  } else {
    error (sorry( "El README no contiene $cadena" ));
  }
}

sub clave_presente {
  my $clave = shift;
  comprueba( $iv->{$clave}, " $clave presente", "Falta clave $clave" );
}
